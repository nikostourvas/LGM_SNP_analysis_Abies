---
title: "LifeGenMon Abies SSR vs SNP"
author: "Nikos Tourvas"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
bibliography: library.bib
output:
  html_notebook:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
    toc_depth: 3
  html_document:
    code_folding: hide
    theme: united
    toc: yes
    ## toc_float: yes
  pdf_document:
    toc: yes
always_allow_html: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include=FALSE)
```

# SNP data set

<!-- # Import csv -->
```{r include=FALSE}
snp <- read.csv("../data/Genotyping-1841.025-03 Grid_reformated.csv", 
                header = T, 
                na.strings = c("?", "Uncallable", "Bad")
               # ,stringsAsFactors = T
               , check.names = F # default is TRUE, and changes the dashes to dots - which created problems
               )
# snp
```


<!-- ## Transform sample names -->
<!-- #### This will allow hierarchical analysis when applicable -->
<!-- #### Country / Species / Pop / Plot -->
```{r include=F}
library(tidyverse)

snp <- snp %>% 
  mutate(Genotype = str_replace_all(Genotype, "^AB", "GR_AB_A_")) %>% #GR_Adult
  mutate(Genotype = str_replace_all(Genotype, "^RAB", "GR_AB")) %>% #GR_Regen
  
  mutate(Genotype = str_replace_all(Genotype, "_A_", "_A_1_")) %>% 
  
  mutate(Genotype = str_replace_all(Genotype, "NR", "NR_"))
```

<!-- ## Remove samples that consistently do not amplify -->
```{r include=F}
# 
# snp_fil <- snp %>% 
#         filter(snpa != "Bad")
# 
# snp_fil
```

<!-- ### Create a df following the guidelines of the loci format -->
```{r include=F}
snp_loci_format <- as.data.frame(sapply(snp, gsub, pattern=':', replacement='/') )
# snp_loci_format <- as.data.frame(sapply(snp_loci_format, gsub, pattern=".", replacement="_"))
snp_loci_format <- snp_loci_format[,-1]
rownames(snp_loci_format) <- snp[,1]

# snp_loci_format
```

```{r include=F}
## Add a second column for population

pop1 <- replicate(124, "DE_AAL_A_1")
pop2 <- replicate(16, "DE_AAL_NR_1")
pop3 <- replicate(16, "DE_AAL_NR_2")
pop4 <- replicate(16, "DE_AAL_NR_3")
pop5 <- replicate(16, "DE_AAL_NR_4")
pop6 <- replicate(124, "GR_AB_A_1")
pop7 <- replicate(20, "GR_AB_NR_1")
pop8 <- replicate(18, "GR_AB_NR_2")
pop9 <- replicate(16, "GR_AB_NR_3")
pop10 <- replicate(10, "GR_AB_NR_4")
pop11 <- replicate(124, "SI_AAL_A_1")
pop12 <- replicate(16, "SI_AAL_NR_1")
pop13 <- replicate(16, "SI_AAL_NR_2")
pop14 <- replicate(16, "SI_AAL_NR_3")
pop15 <- replicate(16, "SI_AAL_NR_4")

pop <- c(pop1, pop2, pop3, pop4, pop5, pop6,
         pop7, pop8, pop9, pop10, pop11,
         pop12, pop13, pop14, pop15)

# pop

snp_loci_format <- add_column(snp_loci_format, pop, .before = "contig00241-160")

# snp_loci_format
```

<!-- ## Create genind object -->
```{r include=F}
library(pegas)

data <- as.loci(snp_loci_format, 
                col.pop = 1
                ,allele.sep = "/")
# data

obj_origin <- loci2genind(data,)
# obj_origin
```

<!-- ### stratify data set -->
```{r include=F}
strata_df <- as.data.frame(snp_loci_format$pop)
colnames(strata_df) <- "strata"
strata_df <- separate(strata_df, col = strata, sep="_", 
                      into = c("Country", 
                               "Species", 
                               "Pop", 
                               "Plot"))
strata(obj_origin) <- strata_df

setPop(obj_origin) <- ~Country/Pop
# obj_origin
```

<!-- #
Data filtering -->

<!-- ### Remove uninformative (monomorphic) loci -->
```{r include=F}
library(poppr)
obj_SNP <- informloci(obj_origin, MAF = 0)
```

<!-- ### Filter out missing data -->
```{r cache=F, fig.width=10, dpi=300, include=FALSE}
threshold <- 0.10

obj_SNP <- missingno(obj_SNP, type = "loci", cutoff = threshold)

obj_SNP <- missingno(obj_SNP, type = "genotypes", cutoff = threshold)
```

<!-- ### Remove uninformative loci -->
```{r include=F}
library(poppr)

maf <- 0.00 
obj_SNP <- informloci(obj_SNP, MAF = maf)
```

### Data filtering thresholds
```{r include=T}
paste("SNP loci:", threshold*100, 
      "% missing data across populations", sep=" ")
```

```{r include=T}
paste("Individuals:", threshold*100, "% missing data", sep=" ")
```

```{r include=T}
paste("SNP loci with minor allele frequency <", maf)
```

### Data set details after data filtering:
```{r include=T}
paste(nInd(obj_SNP), "individuals", "and", nLoc(obj_SNP), "loci", sep=" ")
```



# SSR data set

```{r}
library(popprxl)

obj_SSR <- read.genalexcel(
  "../data/LGM_DE_SI_GR_final.xlsx",   # name of excel file
  sheet = "Abies",             # name of sheet where the genotypes reside
  genclone = F) 


splitStrata(obj_SSR) <- ~Country/Pop
```





# Summary statistics
```{r summary_statistics, cache=T}

## functions

###### basic statistics and their SEs
table_out <- function(obj, variable, name){
  
means <- colMeans(variable, na.rm=T)
out <- c(means, mean(variable, na.rm = T))

out <- as.data.frame(out)
Pops <- c(popNames(obj), "Total")
rownames(out) <- Pops
colnames(out) <- name

sem_out <- apply(variable, 2, function(x) sd(x) / sqrt(length(x))) 
  ## 2 means work along columns
sem_out_mean <- sd(variable) / sqrt(length(variable))

sem_out <- as.data.frame(c(sem_out, sem_out_mean))
rownames(sem_out) <- Pops
colnames(sem_out) <- paste("SE", name, sep = "_")

table_out <- cbind(out, sem_out)

return(table_out)
}




###### basic statistics reported from poppr and their SEs
poppr2hierfstat_out <- function(obj, variable){
  
obj_list <- seppop(obj)
  
stats_poppr <- list()
for(i in 1: length(obj_list)){
  stats_poppr[[i]] <- locus_table(obj_list[[i]], information = F)
}

table_out <- list()
for(i in 1:length(obj_list))
table_out[[i]] <- stats_poppr[[i]][-nrow(stats_poppr[[1]]), variable]

table_out <- as.matrix(as.data.frame(table_out))
colnames(table_out) <- popNames(obj)

return(table_out)
}

```


## SSR
```{r}
library(poppr)
library(hierfstat)
library(reshape2)

## N
N_by_locus <- basic.stats(obj_SSR)[["n.ind.samp"]]
obj_list <- seppop(obj_SSR)
N <- list()
for(i in 1:length(obj_list)){
        N[[i]] <- length(obj_list[[i]]@pop)
}
N <- melt(N)
N <- c(N[,1], sum(N[,1]))

## na
na_by_locus <- poppr2hierfstat_out(obj_SSR, "allele")
na <- table_out(obj_SSR, na_by_locus, "na")


## uHe
uHe_by_locus <- poppr2hierfstat_out(obj_SSR, "Hexp")
uHe <- table_out(obj_SSR, uHe_by_locus, "uHe")

## Ho
Ho_by_locus <- basic.stats(obj_SSR)[["Ho"]]
Ho <- table_out(obj_SSR, Ho_by_locus, "Ho")

## ne
ne_by_locus_Hs <- 1 / (1 - (basic.stats(obj_SSR)[["Hs"]]))
ne_Hs <- table_out(obj_SSR, ne_by_locus_Hs, "ne")

## ## ne
## ne_by_locus_He <- 1 / (1 - (basic.stats(obj_SSR)[["Hs"]]))
## ne_Hs <- table_out(obj_SSR, ne_by_locus, "ne")

## Fis
Fis_by_locus <- basic.stats(obj_SSR)[["Fis"]]
Fis <- table_out(obj_SSR, Fis_by_locus, "Fis") ## better use boot.ppfis

## Private alleles
PA <- rowSums(poppr::private_alleles(obj_SSR, count.alleles=F))
PA <- data.frame(PA)
PA <- rbind(PA, Total=colSums(PA))
```

```{r SummaryTable, cache=T, include=T}
library(kableExtra)

summary_df <- cbind(N, Ho[,1], uHe[,1], Fis[,1], PA)
rownames(summary_df) <- c(popNames(obj_SSR), "Total")
colnames(summary_df) <- c("N", "Ho", "uHe", "Fis", "PA")
summary_df <- round(as.data.frame(summary_df), digits = 3)

knitr::kable(summary_df, "html", digits = 3) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)

## summary_df2 <- cbind(N, na, ne_Hs, Ho, uHe)
## summary_df2
```

N: number of individuals  
Ho: observed heterozygosity  
uHe: unbiased expected heterozygosity - gene diversity [@nei_EstimationAverageHeterozygosity_1978]

Fis: inbreeding coefficient [@nei_MolecularEvolutionaryGenetics_1987]

PA: private alleles

```{r include=T}
setPop(obj_SSR) <- ~Country

# PA <- rep(0, length(popNames(obj_SSR)))
PA <- rowSums(poppr::private_alleles(obj_SSR, count.alleles=F))
PA <- data.frame(PA)
PA <- rbind(PA, Total=colSums(PA))

knitr::kable(PA, "html", digits = 3, 
             caption="Private alleles per cohort") %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
                      

setPop(obj_SSR) <- ~Country/Pop
```

## SNP
```{r}
library(poppr)
library(hierfstat)
library(reshape2)

## N
N_by_locus <- basic.stats(obj_SNP)[["n.ind.samp"]]
obj_list <- seppop(obj_SNP)
N <- list()
for(i in 1:length(obj_list)){
        N[[i]] <- length(obj_list[[i]]@pop)
}
N <- melt(N)
N <- c(N[,1], sum(N[,1]))

## na
na_by_locus <- poppr2hierfstat_out(obj_SNP, "allele")
na <- table_out(obj_SNP, na_by_locus, "na")


## uHe
uHe_by_locus <- poppr2hierfstat_out(obj_SNP, "Hexp")
uHe <- table_out(obj_SNP, uHe_by_locus, "uHe")

## Ho
Ho_by_locus <- basic.stats(obj_SNP)[["Ho"]]
Ho <- table_out(obj_SNP, Ho_by_locus, "Ho")

## ne
ne_by_locus_Hs <- 1 / (1 - (basic.stats(obj_SNP)[["Hs"]]))
ne_Hs <- table_out(obj_SNP, ne_by_locus_Hs, "ne")

## ## ne
## ne_by_locus_He <- 1 / (1 - (basic.stats(obj_SNP)[["Hs"]]))
## ne_Hs <- table_out(obj_SNP, ne_by_locus, "ne")

## Fis
Fis_by_locus <- basic.stats(obj_SNP)[["Fis"]]
Fis <- table_out(obj_SNP, Fis_by_locus, "Fis") ## better use boot.ppfis

## Private alleles

PA_SNP_p <- poppr::private_alleles(obj_SNP, count.alleles=F)
if(is.numeric(PA_SNP_p)){
  PA_SNP <- rowSums(PA_SNP_p)
  PA_SNP <- data.frame(PA)
  PA <- rbind(PA, Total=colSums(PA_SNP))
}else {
  PA_SNP <- rep(0, length(popNames(obj_SNP)) + 1 )
}

```

```{r SummaryTable_SNP, cache=T, include=T}
library(kableExtra)

summary_df <- cbind(N, Ho[,1], uHe[,1], Fis[,1], PA_SNP)
rownames(summary_df) <- c(popNames(obj_SNP), "Total")
colnames(summary_df) <- c("N", "Ho", "uHe", "Fis", "PA")
summary_df <- round(as.data.frame(summary_df), digits = 3)

knitr::kable(summary_df, "html", digits = 3) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)

## summary_df2 <- cbind(N, na, ne_Hs, Ho, uHe)
## summary_df2
```

N: number of individuals  
Ho: observed heterozygosity  
uHe: unbiased expected heterozygosity - gene diversity [@nei_EstimationAverageHeterozygosity_1978]

Fis: inbreeding coefficient [@nei_MolecularEvolutionaryGenetics_1987]

PA: private alleles

```{r include=T}
setPop(obj_SNP) <- ~Country

# PA_SNP_country <- rep(0, length(popNames(obj_SNP)))
PA_SNP_country <- poppr::private_alleles(obj_SNP, count.alleles=F)

if(is.numeric(PA_SNP_country)){
  PA_SNP_country <- rowSums(PA_SNP_country)
  PA_SNP_country <- data.frame(PA_SNP_country)
  PA_SNP_country <- rbind(PA_SNP_country, Total=colSums(PA_SNP_country))

knitr::kable(PA_SNP_country, "html", digits = 3, 
             caption="Private alleles per cohort") %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
                      
}


setPop(obj_SNP) <- ~Country/Pop
```

# Mantel test comparing Nei distance matrices obtained from SSR and SNP
```{r mantel, cache=T, dpi=300, include=T}

# Restrict SSR data set to adults and regen
obj_SSR_sub <- popsub(obj_SSR, blacklist = c("GR_Seed",
                                             "DE_Seed",
                                             "SL_Seed"))
# # create list of population names
# PopNames <- c("DE_A", "DE_NR",
#               "SI_A", "SI_NR",
#               "GR_A", "GR_NR")
# 
# # set pop names in genind object
# popNames(obj_SSR_sub) <- PopNames


# compute distance
D_SNP <- genet.dist(obj_SNP, method = "Ds")

D_SSR <- genet.dist(obj_SSR_sub, method = "Ds")

mantel <- mantel.randtest(D_SNP, D_SSR) 
mantel

# plot(ibd)

# library(MASS)
# dens <- kde2d(Dgeo,Dgen, n=300)
# myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
# plot(Dgeo, Dgen, pch=20,cex=.5,
#      ylab="Cavalli-Sforza genetic distance",
#      xlab="Geographical distance (euclidean)")
# image(dens, col=transp(myPal(300),.7), add=TRUE)
# abline(lm(Dgen~Dgeo))
# title("Isolation by distance")

plot(D_SSR, D_SNP, pch=20,cex=1,
     ylab="Nei genetic distance SNP",
     xlab="Nei genetic distance SSR")
abline(lm(D_SNP~D_SSR))
title("Mantel test of Distance Matrices")
```

```{r include=T}
library(ecodist)

ecodist::mantel(D_SNP ~ D_SSR)
```

```{r fig.height=4, fig.width=4}
library(vegan)

vegan::mantel(D_SNP, D_SSR, method = "pearson", permutations = 999)

plot(D_SSR, D_SNP, pch=20,cex=1,
     ylab="Nei genetic distance SNP",
     xlab="Nei genetic distance SSR")
abline(lm(D_SNP~D_SSR))
title("Mantel test of Distance Matrices")
```


# Probability of assignment using DAPC [@jombart_DiscriminantAnalysisPrincipal_2010a]

## calculate DAPC for different number of SSR loci
```{r}
setPop(obj_SSR_sub) <- ~Country

loci <- sort(nAll(obj_SSR_sub)) # vector containing loci from least to
# most polymorphic according to thlocie pooled dataset from all countries and pops
loci <- names(loci) # transform named vector to vector of names

data <- list()
for(i in 1:length(loci)){
  data[[length(loci)+1-i]] <- obj_SSR_sub[, loc = loci[i:length(loci)]]
}
```

## SSR
```{r}
dapc_SSR <- list()
for(i in 1:length(loci)){
  dapc_SSR[[i]] <- dapc(data[[i]], obj_SSR_sub@pop, 
                        n.pca=round(nrow(obj_SSR@tab)/1.5), n.da=5)
}
```

## SNP
```{r}
setPop(obj_SNP) <- ~Country

dapc_SNP <- dapc(obj_SNP, obj_SNP@pop, n.pca=round(nrow(obj_SNP@tab)/1.5), n.da=5)
```

## plot
```{r include=T}
# code adapted from http://www.mountainmanmaier.com/software/ms_vs_ddradseq/
thresh <- list()
  for(i in 1:length(loci)){
    thresh[[i]] <- summary(dapc_SSR[[i]])$assign.prop
  }

thresh <- unlist(thresh)
    
rad.power <- data.frame(nloc=numeric(0), mean=numeric(0), CIlow=numeric(0), CIhigh=numeric(0))
gi.test.1 <- obj_SNP
for (i in seq(25, length(locNames(obj_SNP)), 20)) {
  CIreps <- c()
  for (j in 1:10) {
    gi.test.2 <- gi.test.1[,loc=sample(1:length(unique(gi.test.1@loc.fac)), i)]
    dapc.test <- dapc(gi.test.2, gi.test.2@pop, n.pca=round(nrow(gi.test.2@tab)/1.5), n.da=5)
    CIreps <- c(CIreps, summary(dapc.test)$assign.prop)
  }
  assign.mean <- mean(CIreps)
  error <- qt(0.975,df=9)*sd(CIreps)/sqrt(10)
  CIlow <- assign.mean - error
  CIhigh <- assign.mean + error
  rad.power <- rbind(rad.power, c(i, assign.mean, CIlow, CIhigh))
  names(rad.power) <- c("nloc", "mean", "CIlow", "CIhigh")
}
```

```{r}
ggplot(rad.power, aes(x=nloc, y=mean)) + 
  geom_ribbon(aes(ymin=CIlow, ymax=CIhigh), alpha=0.2) +
  geom_line(aes(y=mean), colour="blue") + 
  geom_point(color="black") +
  geom_hline(aes(yintercept = thresh[[3]], linetype="a", colour="a")) +
  geom_hline(aes(yintercept = thresh[[5]], linetype="a", colour="a")) +
  geom_hline(aes(yintercept = thresh[[11]], linetype="a", colour="a")) +
  scale_x_continuous(breaks=c(0, 40, 80, 120, 160, 185)) +
  scale_y_continuous(breaks=c(0.8, 0.85, 0.9, 0.95, 1.0)) +
  ggtitle("Power of SNP Loci to Discriminate Cohorts") +
  xlab("Number of SNP Loci") + ylab("Individuals Correctly Assigned (%)") +
  theme_bw() + theme(plot.title = element_text(hjust = 0.5), legend.position="none")
```
Red line: assignment ability of common SSR data set of 3, 5, 11 loci based on DAPC



```{r}
setPop(obj_SSR_sub) <- ~Country/Pop
setPop(obj_SNP) <- ~Country/Pop
```

# 2 Probability of assignment using DAPC [@jombart_DiscriminantAnalysisPrincipal_2010a]
```{r}
setPop(obj_SSR) <- ~Country
setPop(obj_SNP) <- ~Country


dapc_SSR <- dapc(obj_SSR, obj_SSR@pop, n.pca=round(nrow(obj_SSR@tab)/1.5), n.da=5)
dapc_SNP <- dapc(obj_SNP, obj_SNP@pop, n.pca=round(nrow(obj_SNP@tab)/1.5), n.da=5)
```

```{r}
par(mfrow=c(1,2)) # Set plotting window for two side-by-side plots
myCol <- topo.colors(3)

scatter(dapc_SSR, scree.da=F, bg="white", pch=20, cell=0, cstar=0, col=myCol, solid=.2, cex=0.5, clab=0, leg=T, txt.leg=c(as.character(unique(obj_SSR$pop))), 
        cleg=0.55, posi.leg="bottomright")

scatter(dapc_SNP, scree.da=F, bg="white", pch=20, cell=0, cstar=0, col=myCol, solid=.2, cex=1, clab=0, leg=T, txt.leg=c(as.character(unique(obj_SNP$pop))), 
        cleg=0.55, posi.leg="bottomright")
```

```{r}
par(mfrow=c(1,2)) # Set plotting window for two side-by-side plots
table.value(table(dapc_SSR$assign, obj_SSR@pop), col.lab=levels(obj_SSR@pop))
table.value(table(dapc_SNP$assign, obj_SNP@pop), col.lab=levels(obj_SNP@pop))
```

```{r include=T}
# code adapted from http://www.mountainmanmaier.com/software/ms_vs_ddradseq/
thresh <- summary(dapc_SSR)$assign.prop
rad.power <- data.frame(nloc=numeric(0), mean=numeric(0), CIlow=numeric(0), CIhigh=numeric(0))
gi.test.1 <- obj_SNP
for (i in seq(10, length(locNames(obj_SNP)), 20)) {
  CIreps <- c()
  for (j in 1:100) {
    gi.test.2 <- gi.test.1[,loc=sample(1:length(unique(gi.test.1@loc.fac)), i)]
    dapc.test <- dapc(gi.test.2, gi.test.2@pop, n.pca=round(nrow(gi.test.2@tab)/1.5), n.da=5)
    CIreps <- c(CIreps, summary(dapc.test)$assign.prop)
  }
  assign.mean <- mean(CIreps)
  error <- qt(0.975,df=9)*sd(CIreps)/sqrt(10)
  CIlow <- assign.mean - error
  CIhigh <- assign.mean + error
  rad.power <- rbind(rad.power, c(i, assign.mean, CIlow, CIhigh))
  names(rad.power) <- c("nloc", "mean", "CIlow", "CIhigh")
}

ggplot(rad.power, aes(x=nloc, y=mean)) + 
  geom_ribbon(aes(ymin=CIlow, ymax=CIhigh), alpha=0.2) +
  geom_line(aes(y=mean), colour="blue") + 
  geom_point(color="black") +
  geom_hline(aes(yintercept = thresh, linetype="a", colour="a")) +
  scale_x_continuous(breaks=c(0, 40, 80, 120, 160, 185)) +
  scale_y_continuous(breaks=c(0.4, 0.6, 0.8, 1.0)) +
  ggtitle("Power of SNP Loci to Discriminate Cohorts") +
  xlab("Number of SNP Loci") + ylab("Proportion of Individuals Correctly Assigned") +
  theme_bw() + theme(plot.title = element_text(hjust = 0.5), legend.position="none")
```
Red line: assignment ability of common SSR data set of 11 loci based on DAPC

```{r}
setPop(obj_SSR) <- ~Country/Pop
setPop(obj_SNP) <- ~Country/Pop
```


# Bibliography