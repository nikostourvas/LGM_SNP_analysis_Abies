---
title: "LifeGenMon Abies SNP analysis"
author: "Nikos Tourvas"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
# bibliography: library.bib
output:
  html_notebook:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
    toc_depth: 3
  html_document:
    code_folding: hide
    theme: united
    toc: yes
    ## toc_float: yes
  pdf_document:
    toc: yes
always_allow_html: yes
---

```{r libraries, echo=TRUE}
# suppressPackageStartupMessages({
  library(adegenet)
  library(popprxl)
  library(hierfstat)
  library(magrittr)
  library(pegas)
  ## library(genepop)
  library(mmod)
  library(ape)
  library(phangorn)
  library(tidyverse)
  library(reshape2)
  library(strataG)
  library(ggplot2)
  library(lattice)
  library(factoextra)
  library(ggord)
  library(RColorBrewer)
  ## library(ggcompoplot)
  library(kableExtra)
  library(pophelper)
  library(gridExtra)
  library(radiator)
  library("pcadapt")
  library("qvalue")
# })
```

```{r}
# library(readr)
# snp <- read_csv("data/Genotyping-1841.025-03 Grid_EDITED.csv", 
#     na = c("?", "Uncallable", "Bad") )
# 
# snp
```


# Import csv
```{r import_csv}
snp <- read.csv("../data/Genotyping-1841.025-03 Grid_reformated.csv", 
                header = T, 
                na.strings = c("?", "Uncallable", "Bad")
               # ,stringsAsFactors = T
               , check.names = F # default is TRUE, and changes the dashes to dots - which created problems
               )
# snp
```


## Transform sample names
#### This will allow hierarchical analysis when applicable
#### Country / Species / Pop / Plot
```{r}
snp <- snp %>% 
  mutate(Genotype = str_replace_all(Genotype, "^AB", "GR_AB_A_")) %>% #GR_Adult
  mutate(Genotype = str_replace_all(Genotype, "^RAB", "GR_AB")) %>% #GR_Regen
  
  mutate(Genotype = str_replace_all(Genotype, "_A_", "_A_1_")) %>% 
  
  mutate(Genotype = str_replace_all(Genotype, "NR", "NR_"))
```


## Remove samples that consistently do not amplify
```{r remove_bad}
# 
# snp_fil <- snp %>% 
#         filter(snpa != "Bad")
# 
# snp_fil
```

### Create a df following the guidelines of the loci format
```{r}
snp_loci_format <- as.data.frame(sapply(snp, gsub, pattern=':', replacement='/') )
# snp_loci_format <- as.data.frame(sapply(snp_loci_format, gsub, pattern=".", replacement="_"))
snp_loci_format <- snp_loci_format[,-1]
rownames(snp_loci_format) <- snp[,1]

# snp_loci_format
```

```{r}
## Add a second column for population

pop1 <- replicate(124, "DE_AAL_A_1")
pop2 <- replicate(16, "DE_AAL_NR_1")
pop3 <- replicate(16, "DE_AAL_NR_2")
pop4 <- replicate(16, "DE_AAL_NR_3")
pop5 <- replicate(16, "DE_AAL_NR_4")
pop6 <- replicate(124, "GR_AB_A_1")
pop7 <- replicate(20, "GR_AB_NR_1")
pop8 <- replicate(18, "GR_AB_NR_2")
pop9 <- replicate(16, "GR_AB_NR_3")
pop10 <- replicate(10, "GR_AB_NR_4")
pop11 <- replicate(124, "SI_AAL_A_1")
pop12 <- replicate(16, "SI_AAL_NR_1")
pop13 <- replicate(16, "SI_AAL_NR_2")
pop14 <- replicate(16, "SI_AAL_NR_3")
pop15 <- replicate(16, "SI_AAL_NR_4")

pop <- c(pop1, pop2, pop3, pop4, pop5, pop6,
         pop7, pop8, pop9, pop10, pop11,
         pop12, pop13, pop14, pop15)

# pop

snp_loci_format <- add_column(snp_loci_format, pop, .before = "contig00241-160")

# snp_loci_format
```

## Create genind object
```{r}
library(pegas)

data <- as.loci(snp_loci_format, 
                col.pop = 1
                ,allele.sep = "/")
# data

obj_origin <- loci2genind(data,)
# obj_origin
```

### stratify data set
```{r test}
strata_df <- as.data.frame(snp_loci_format$pop)
colnames(strata_df) <- "strata"
strata_df <- separate(strata_df, col = strata, sep="_", 
                      into = c("Country", 
                               "Species", 
                               "Pop", 
                               "Plot"))
strata(obj_origin) <- strata_df

setPop(obj_origin) <- ~Country/Pop
obj_origin
```

# Data filtering

### Check for missing data
```{r missing, cache=F, fig.width=10, dpi=300}
capture.output(
info_table(obj_origin, type = "missing", plot = TRUE, plotlab = F),
file='NUL') 
## capture.output is used to hide printing of the table on the console

div <- summary(obj_origin)

# paste("Total missing data is",  round(div$NA.perc, digits = 2), "%", sep = " ")
```

### Percent (%) of missing data by pop
```{r missing_by_pop}
library(purrr)
missing_by_pop <- as.data.frame(
  seppop(obj_origin) %>% 
  lapply(adegenet::summary) %>% 
  map_depth(1, "NA.perc")
)

knitr::kable(missing_by_pop, digits = 2, format = "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)
```

### How many loci are biallelic?
```{r fig.height=3, fig.width=3, cache=T, dpi=300}
alleles_per_locus <- nAll(obj_origin)

number_df <- as.data.frame(alleles_per_locus)

ggplot(number_df, aes(x=alleles_per_locus) ) +
  geom_bar(color="black", fill="white",
           width = 0.5) +
  scale_x_continuous(breaks = c(1,2,3,4))

perc_bi <- number_df %>% 
  group_by(alleles_per_locus) %>% 
  count() %>% 
  mutate("percent_(%)" = round(n / nLoc(obj_origin) * 100,  digits = 2))%>% 
  rename("alleles per locus" = alleles_per_locus,
         occurences = n,
         "occurences (%)" = "percent_(%)")


knitr::kable(perc_bi, "html", digits = 2) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
```

### Remove uninformative (monomorphic) loci
```{r maf}
obj <- informloci(obj_origin, MAF = 0)
```

### Filter out missing data
```{r missing2, cache=F, fig.width=10, dpi=300}
obj <- missingno(obj, type = "loci", cutoff = 0.10)

obj <- missingno(obj, type = "genotypes", cutoff = 0.15)

test <- seppop(obj) %>% 
  lapply(propTyped, by="loc") %>% 
  lapply(sort)

capture.output(
info_table(obj, type = "missing", plot = TRUE, plotlab = F),
file='NUL')
```

# Summary statistics
```{r summary_statistics, cache=T}

## functions

###### basic statistics and their SEs
table_out <- function(obj, variable, name){
  
means <- colMeans(variable, na.rm=T)
out <- c(means, mean(variable, na.rm = T))

out <- as.data.frame(out)
Pops <- c(popNames(obj), "Total")
rownames(out) <- Pops
colnames(out) <- name

sem_out <- apply(variable, 2, function(x) sd(x) / sqrt(length(x))) 
  ## 2 means work along columns
sem_out_mean <- sd(variable) / sqrt(length(variable))

sem_out <- as.data.frame(c(sem_out, sem_out_mean))
rownames(sem_out) <- Pops
colnames(sem_out) <- paste("SE", name, sep = "_")

table_out <- cbind(out, sem_out)

return(table_out)
}




###### basic statistics reported from poppr and their SEs
poppr2hierfstat_out <- function(obj, variable){
  
obj_list <- seppop(obj)
  
stats_poppr <- list()
for(i in 1: length(obj_list)){
  stats_poppr[[i]] <- locus_table(obj_list[[i]], information = F)
}

table_out <- list()
for(i in 1:length(obj_list))
table_out[[i]] <- stats_poppr[[i]][-nrow(stats_poppr[[1]]), variable]

table_out <- as.matrix(as.data.frame(table_out))
colnames(table_out) <- popNames(obj)

return(table_out)
}

```

```{r}
## N
N_by_locus <- basic.stats(obj)[["n.ind.samp"]]
obj_list <- seppop(obj)
N <- list()
for(i in 1:length(obj_list)){
        N[[i]] <- length(obj_list[[i]]@pop)
}
N <- melt(N)
N <- c(N[,1], sum(N[,1]))

## na
na_by_locus <- poppr2hierfstat_out(obj, "allele")
na <- table_out(obj, na_by_locus, "na")


## uHe
uHe_by_locus <- poppr2hierfstat_out(obj, "Hexp")
uHe <- table_out(obj, uHe_by_locus, "uHe")

## Ho
Ho_by_locus <- basic.stats(obj)[["Ho"]]
Ho <- table_out(obj, Ho_by_locus, "Ho")

## ne
ne_by_locus_Hs <- 1 / (1 - (basic.stats(obj)[["Hs"]]))
ne_Hs <- table_out(obj, ne_by_locus_Hs, "ne")

## ## ne
## ne_by_locus_He <- 1 / (1 - (basic.stats(obj)[["Hs"]]))
## ne_Hs <- table_out(obj, ne_by_locus, "ne")

## Fis
Fis_by_locus <- basic.stats(obj)[["Fis"]]
Fis <- table_out(obj, Fis_by_locus, "Fis") ## better use boot.ppfis

```

```{r SummaryTable, cache=T}
summary_df <- cbind(N, na[,1], ne_Hs[,1], Ho[,1], uHe[,1], Fis[,1])
rownames(summary_df) <- c(popNames(obj), "Total")
colnames(summary_df) <- c("N", "na", "ne", "Ho", "uHe", "Fis")
summary_df <- round(as.data.frame(summary_df), digits = 3)

knitr::kable(summary_df, "html", digits = 3) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)

## summary_df2 <- cbind(N, na, ne_Hs, Ho, uHe)
## summary_df2
```
N: number of individuals  
na: number of alleles per locus  
ne: number of effective alleles  
Ho: observed heterozygosity  
uHe: unbiased expected heterozygosity - gene diversity [@nei_EstimationAverageHeterozygosity_1978]  
Fis: inbreeding coefficient [@nei_MolecularEvolutionaryGenetics_1987]


```{r}
uHe <- uHe %>% 
  mutate(upper = uHe + 2 * SE_uHe) %>% 
  mutate(lower = uHe - 2 * SE_uHe) %>% 
  add_column(population = c(popNames(obj), "Total") )
```

```{r fig.height=3, fig.width=5}
uHe2 <- uHe[-nrow(uHe),] %>%
  add_column(age = c("A","NR",
                            "A","NR",
                            "A","NR"))

p <- ggplot(uHe2, aes(x=population, y=uHe, fill = age)) +
  geom_bar(stat = "identity", 
           color="black",
           # fill = c("white", "lightgrey"),
           width = .6) +
  scale_y_continuous(breaks = seq(0, 0.3, 0.05)) +
  geom_errorbar(aes(ymin=lower, ymax=upper),
                width = .3) +
  ggtitle("uHe (95% CIs)") +
  theme_classic() +
  scale_fill_manual(values=c("white", "lightgrey") ) +
  theme(legend.position = "none")

p 
```

```{r fig.height=3, fig.width=5}
uHe_by_locus_tidy <- gather(as.data.frame(uHe_by_locus), 
                            key = "population",
                            value = "uHe")

uHe_by_locus_tidy %>% 
ggplot(aes(x = population, y = uHe) ) +
  geom_violin() +
  # geom_boxplot(width=.1) +
  stat_summary(fun.y=mean, 
                 geom="point") +
  ggtitle("uHe") +
  theme_classic()

```

```{r}
Fis <- as.data.frame(Fis[-nrow(Fis), 1] )
colnames(Fis) <- "Fis"
boot.fis <- boot.ppfis(obj, nboot=1000)

Fis <- bind_cols(Fis, boot.fis$fis.ci)

Fis <- Fis %>% 
  add_column(population = popNames(obj), .before = Fis$Fis )
```

```{r fig.height=3, fig.width=5}
Fis %>% 
ggplot(aes(x=population, y=Fis)) +
  geom_point(stat = "identity", 
           color="black", fill = "lightgrey",
           size = 2) +
  scale_y_continuous(breaks = seq(-0.5, 0.5, 0.02)) +
  geom_errorbar(aes(ymin=ll, ymax=hl),
                width = .3) +
  ggtitle("Fis (95% CIs)") +
  theme_classic()
```

```{r cache=T, dpi=300, fig.width=5, fig.height=3}
div <- summary(obj)

all <- as.data.frame(div$pop.n.all)
all <- all %>% 
  mutate(population = rownames(all)) %>% 
  rename(count = "div$pop.n.all")

all$count <- as.integer(all$count)

# str(all)

ggplot(all, aes(x=population, y=count) ) +
  geom_bar(stat = "identity", 
           color = "black", fill = "white",
           width = .8) +
  geom_text(aes(label=count, vjust = 1.6)) +
  ggtitle("Total Number of alleles per population")
```

### Private alleles per cohort - level Country/Pop
```{r private_pops, cache=TRUE, dpi=300, fig.width=8.5}
private <- poppr::private_alleles(obj, report = "data.frame")

if(is.data.frame(private)){
  
ggplot(private) + geom_tile(aes(x = population,
                                y = allele,
                                fill = count)) +
  ggtitle("Private alleles per population") +
  scale_fill_viridis_c()
  
}
```

### Private alleles per cohort - level Country
```{r}
setPop(obj) <- ~Country

private <- poppr::private_alleles(obj, 
                                  report = "data.frame")


if(is.data.frame(private)){

ggplot(private) + geom_tile(aes(x = population,
                                y = allele,
                                fill = count)) +
  ggtitle("Private alleles per cohort") +
  scale_fill_viridis_c()
  
}

setPop(obj) <- ~Country/Pop
```

```{r}
setPop(obj) <- ~Country

PA <- rowSums(poppr::private_alleles(obj, count.alleles=F))
if(is.numeric(PA)){
  PA <- data.frame(PA)
  PA <- rbind(PA, Total=colSums(PA))
  
  knitr::kable(PA, "html", digits = 3, 
             caption="Private alleles per cohort") %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
  
}else{
  print("No private alleles detected")
}


                      

setPop(obj) <- ~Country/Pop
```


```{r LD_r, eval=FALSE, fig.height=10, dpi=300, include=FALSE}
### LD
# Index of association

rd1 <- seppop(obj) %>% lapply(pair.ia, plot = F, quiet = T)
# seppop: separates dataset by pop

# Consistent range in the plotted graphics
plotrange <- range(rd1, na.rm = TRUE)
# Re-plot the graphics
rd <- seppop(obj) %>% 
  lapply(pair.ia, limits = plotrange, quiet = T,
         sample = 999)
```

### LD
```{r}
library(genetics)

# Choose hierarchical level
setPop(obj) <- ~Country

loci_list <- seppop(obj) %>% 
                lapply(genind2loci)

LD_list <- lapply(loci_list, 
                function(x)x[,-1] ) %>% 
           lapply(makeGenotypes) %>% 
           lapply(genetics::LD)
```

```{r}
LD_list_df <- 
        lapply(LD_list,
               function(x)x$`P-value`)

ind <- lapply(LD_list_df, function(x){
        which(upper.tri(x, diag = TRUE), arr.ind = TRUE)
})

nn <- lapply(LD_list_df, function(x){
        dimnames(x)
})


LD_list_df.long <- list()
for(i in popNames(obj)){
LD_list_df.long[[i]] <- na.omit(
  data.frame(locus1 = nn[[i]][[1]] [ ind[[i]][, 1] ],
           locus2 = nn[[i]][[2]] [ ind[[i]][, 2] ],
           pvalue = LD_list_df[[i]] [ ind[[i]] ])
        )
}

# test4 <- list()
# for(i in popNames(obj)){
#         test4[[i]] <- test3[[i]] %>%
#   add_column(loci =
#               as.factor(
#                     paste(test3[[i]]$locus1,
#                          test3[[i]]$locus2,
#                          sep = "_")
#                     ), .before = test3[[i]]$pvalue
#   )
# }
# 
# for(i in popNames(obj)){
#         test4[[i]] <- test4[[i]] [,-(2:3)]
# }

# significant LD after multiple test correction
for(i in popNames(obj)){
LD_list_df.long[[i]]$p.adjust <- p.adjust(LD_list_df.long[[i]]$pvalue, 
                              method = "holm")
}

LD_sig <- lapply(LD_list_df.long, filter,
                    p.adjust < 0.05)

LD_sig_intersect <- intersect(LD_sig$DE,
                          LD_sig$GR,
                          LD_sig$SI)
LD_sig_intersect <- LD_sig_intersect[,1:2]
LD_sig_intersect


# check if sig LDs are on the same or on diff contigs
LD_contig <- LD_sig_intersect

LD_contig$locus1 <- str_replace_all(LD_sig_intersect$locus1,
                    pattern = "-.+",
                    replacement = "")

LD_contig$locus2 <- str_replace(LD_sig_intersect$locus2,
                    pattern = "-.+",
                    replacement = "")

invisible(
LD_contig <- LD_contig %>% 
  mutate(same.contig = locus1 == locus2)
)

paste(sum(LD_contig$same.contig), "pairs of loci on the same contig")



LD_sig_df <- melt(
  lapply(LD_sig, nrow)
)

LD_sig_df <- LD_sig_df %>% 
        rename(population = L1,
               "N of pairs of loci with significant LD" = value)
LD_sig_df
```

```{r}
setwd("../results")

for(i in 1:length(LD_list_df.long))
write.csv(LD_list_df.long[[i]], file = paste(popNames(obj)[i], 
                                       "LD.csv", sep = "_"))

# reset pop structure
setPop(obj) <- ~Country/Pop
```

LD between all pairs of loci was tested seperately for all three cohorts (DE, GR, SI). 

The Holm-Bonferroni method was employed to account for multiple testing. [citation]

Significant LD was detected on 131 loci for the German cohort, 80 loci for the Greek cohort, and 104 loci for the Slovenian cohort.

Nine pairs of SNPs (one on different contigs, eight on the same contig), exhibited significant LD across all cohorts.

### Hardy - Weinberg equilibrium
```{r HWE, fig.width=9, fig.height=20, dpi=300, cache=TRUE}
hw.obj <- seppop(obj, drop=T) %>% 
  lapply(hw.test, B = 0)
## seppop: calculates p-value for each locus of every pop
## B: number of permutations

# Re-Write HWE p.adjust
hw.obj.df <- hw.obj %>% 
  lapply(as.data.frame)

# Use p-values from chi-square (col 3) or exact test (col 4)
p.adjust.HWE <- function(x){
  mutate(x, p_adj = p.adjust(x[,3], method = "holm") )
}

hw.obj.df <- lapply(hw.obj.df, p.adjust.HWE)

for(i in 1:length(hw.obj)){
rownames(hw.obj.df[[i]]) <- rownames(hw.obj[[i]])
}

## Isolate adjusted p-values either from chi2 test (j=4) or 
## from exact test (j=5)
hw.mat.adj <- sapply(hw.obj.df, "[", i = TRUE, j = 4)
rownames(hw.mat.adj) <- rownames(hw.obj.df[[1]])

levelplot(t(hw.mat.adj), aspect = "fill", 
          xlab="Pop", ylab="Marker", 
  main = "HWE chi-square p-values after Holm-Bonferroni correction")

# kable(hw.obj.df[[1]], "html",
# caption = "HWE exact test p-values after Holm-Bonferroni
# correction (1000 permutations)") %>%
#  kable_styling(bootstrap_options = "striped", full_width = F)

setwd("../results")

for(i in 1:length(hw.obj.df))
write.csv(hw.obj.df[[i]], file = paste(popNames(obj)[i], 
                                       "HWE.csv", sep = "_"))
```

```{r eval=F}
typeof(hw.mat)
hw.mat
```

# Genetic Differentiation
```{r matrix_fun}
## Get lower triangle of the matrix 
  get_lower_tri<-function(matrix){
    matrix[upper.tri(matrix, diag = T)] <- NA
    matrix <- matrix[-1, -ncol(matrix)]
    return(matrix)
  }
```

### F~ST~ (G~ST~) [@nei_MolecularEvolutionaryGenetics_1987]
```{r Fst_table, cache=T}
library(hierfstat)
pair_fst <- genet.dist(obj, method = "Nei87")
pair_fst <- as.data.frame(as.matrix(pair_fst))
  
## print table with knitr  
pair_fst <- get_lower_tri(pair_fst)  
options(knitr.kable.NA = '')  


knitr::kable(pair_fst, "html", digits = 4) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r Fst_table2, cache=T}
# library(hierfstat)
setPop(obj) <- ~Country
pair_fst <- genet.dist(obj, method = "Nei87")
pair_fst <- as.data.frame(as.matrix(pair_fst))
  
## print table with knitr  
pair_fst <- get_lower_tri(pair_fst)  
options(knitr.kable.NA = '')  


knitr::kable(pair_fst, "html", digits = 4) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)

# reset hierarchy
setPop(obj) <- ~Country/Pop
```

### Nm based on F~ST~ (G~ST~) [@nei_MolecularEvolutionaryGenetics_1987]
#### ATTN: Results differ from GenAlEx, as this calculates Nm based on the original F~ST~
```{r}
x <- basic.stats(obj)
Nm <- ( (1 / x[["perloc"]][["Fst"]]) - 1) / 4

Nm_mean <- mean(Nm)

Nm_se <- sd(Nm) / sqrt(length(Nm))

Nm_df <- data.frame(
        Nm = round (Nm_mean, digits=2),
        se = round( Nm_se, digits = 2)
)

knitr::kable(Nm_df, "html", digits = 4) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r}
# check this from strataG package
# Nm_strG <- fstToNm(fst, 2)
```

### Cavalli-Sforza and Edwards Chord distance [@cavallisforza_PhylogeneticAnalysisModels_1967]
```{r cavalli-sforza_1, fig.width = 10, dpi=300, cache=T}
## https://groups.google.com/forum/##!topic/poppr/vEQ8vb2oObQ

## create hierfstat input file
obj_hier <- genind2hierfstat(obj)

## create cav-sf distance table
cav_sf <- genet.dist(obj_hier, method = "Dch")
cav_sf <- as.matrix(cav_sf)
pop_vector <- popNames(obj)
colnames(cav_sf) <- pop_vector
rownames(cav_sf) <- pop_vector

## print table with knitr  
cav_sf <- get_lower_tri(cav_sf)  
options(knitr.kable.NA = '')  
knitr::kable(cav_sf, "html", digits = 4,
  caption = "Cavalli-Sforza and Edwards Chord distance between populations") %>% 
  
kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r cavalli-sforza_2, fig.width = 10, dpi=300, cache=T}
# functions
fungen <- function(pop_column) {
  force(pop_column)
  function(x) {
    dat <- cbind(pop_column, x)
    res <- nj(genet.dist(dat, method = "Dch"))
    res$tip.label <- levels(dat[[1]])
    res
  }
}

genet.tree.nj <- fungen(obj_hier[1])

fungen <- function(pop_column) {
  force(pop_column)
  function(x) {
    dat <- cbind(pop_column, x)
    res <- upgma(genet.dist(dat, method = "Dch"))
    res$tip.label <- levels(dat[[1]])
    res
  }
}

genet.tree.upgma <- fungen(obj_hier[1])
```


```{r fig.width = 10, dpi=300, cache=T}
# Create tree
tree_upgma <- genet.tree.upgma(obj_hier[-1])
num_boot <- 100
tree_upgma$node.label <- boot.phylo(phy = tree_upgma, x = obj_hier[-1],
                                    FUN = genet.tree.upgma, B = num_boot
                                    , jumble = FALSE
                                    , mc.cores = 4  # does not work on Windows
                                    )
```

```{r fig.width = 10, dpi=300, cache=T}
# Display tree
nodelabs <- (100 / num_boot) *  tree_upgma$node.label
nodelabs[nodelabs < 50] <- NA
plot.phylo(tree_upgma, cex = 1, font = 2, adj = 0, xpd = TRUE,
           label.offset = 0.0001)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8,
           font = 3, xpd = TRUE)
title(main = "Dendrogram based on Cavalli-Sforza and Edwards Chord distance",
      sub = "method: UPGMA, 1000 Bootstraps")
axisPhylo(side = 1)
```

```{r fig.width = 10, dpi=300, cache=T}
# Create tree
tree_nj <- genet.tree.nj(obj_hier[-1])
num_boot <- 100 # number of bootstraps
tree_nj$node.label <- boot.phylo(phy = tree_nj, x = obj_hier[-1], 
                                 FUN = genet.tree.nj, B = num_boot
                                 , jumble = FALSE
                                 , mc.cores = 4  # does not work on Windows
)
```

```{r fig.width = 10, dpi=300, cache=T}
# Display tree
nodelabs <- (100 / num_boot) *  tree_nj$node.label
nodelabs[nodelabs < 50] <- NA # hide values below 50
plot.phylo(tree_nj, cex = 1, font = 2, adj = 0, xpd = TRUE, 
           label.offset = 0.0001, type = "phylogram")
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
           font = 3, xpd = TRUE)
title(main = "Dendrogram based on Cavalli-Sforza and Edwards Chord distance",
      sub = "method: Neighbor-Joining, 1000 Bootstraps")
add.scale.bar(lwd = 2, length = 0.005, x = 0.01, y=1)
# to find optimal position for scale bar write on the console:
# locator(1)
# and click on the plot where you want to place the scale bar
```

### Nei distance [@nei_EstimationAverageHeterozygosity_1978]
```{r nei_hierfstat, cache=T}
## create nei distance table
nei <- genet.dist(obj, method = "Ds")
nei <- as.matrix(nei)
pop_vector <- popNames(obj)
colnames(nei) <- pop_vector
rownames(nei) <- pop_vector


## print table with knitr  
nei <- get_lower_tri(nei)
options(knitr.kable.NA = '')  
kable(nei, "html", digits = 4,
      caption = "Nei's Standard genetic distance between populations") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r nei_poppr, fig.width = 10, dpi=300, cache=T}
set.seed(1994)


tree_upgma <- aboot(obj, strata = ~Country/Pop, sample = 1000, 
                    cutoff = 50, distance = "nei.dist", 
                    tree = "upgma",showtree = F)
```

```{r fig.width = 10, dpi=300, cache=T}
nodelabs <- round(tree_upgma$node.label, 2)
plot.phylo(tree_upgma, cex = 1, font = 2, adj = 0, xpd = TRUE, 
label.offset = 0.0001,
tip.color = c(rep("blue", 2), rep("red", 2), rep("green", 2)) 
)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
font = 3, xpd = TRUE)
title(main = "Dendrogram based on Nei's standard genetic distance",
      sub = "method: UPGMA, 1000 Bootstraps")
axisPhylo(side = 1)
```

```{r fig.width = 10, dpi=300, cache=T}
tree_nj <- aboot(obj, strata = ~Country/Pop, sample = 1000, cutoff = 50,
                 distance = "nei.dist", tree = "nj", showtree = F)
```

```{r fig.width = 10, dpi=300, cache=T}
nodelabs <- round(tree_nj$node.label, 2)
plot.phylo(tree_nj, cex = 1, font = 2, adj = 0, xpd = TRUE, 
label.offset = 0.0001)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
font = 3, xpd = TRUE)
title(main = "Dendrogram based on Nei's standard genetic distance",
      sub = "method: Neighbor-Joining, 1000 Bootstraps")
add.scale.bar(lwd = 2, length = 0.01, x = 0.01, y=1)
```

### Principal Component Analysis (PCA)
```{r pca, dpi=96, cache=T, fig.width=5, fig.height=3}
## In case there are missing data, replace with mean
X <- tab(obj, freq = TRUE, NA.method = "mean") 

pca.obj <- dudi.pca(X, scale = FALSE, scannf = FALSE, nf = 3)

fviz_eig(pca.obj, main = "Scree plot of PCA")
```

```{r pca_plots, fig.width=10, dpi=300, cache=T}
ggord(pca.obj, pop(obj), arrow = NULL, txt = NULL, 
      grp_title="Populations", ellipse=T, poly=FALSE, size=2, 
      alpha=.8, coord_fix=F, axes = c("1", "2")) +
  geom_hline(yintercept=0,linetype=2) + 
  geom_vline(xintercept=0,linetype=2) +
  ggtitle("Principal Component Analysis") +
  scale_shape_manual('Groups', values = 0:5) +
  scale_color_manual('Groups', values = 
                       c('#1b9e77','#d95f02','#7570b3',
                         '#e7298a','#66a61e','#e6ab02') )

# ggord(pca.obj, pop(obj), arrow = NULL, txt = NULL, 
# grp_title="Populations", ellipse=T, poly=FALSE, size=2, 
# alpha=.8, coord_fix=F, axes = c("1", "3")) +
#   geom_hline(yintercept=0,linetype=2) + 
#   geom_vline(xintercept=0,linetype=2) +
#   ggtitle("Principal Component Analysis") +
#   scale_shape_manual('Groups', values = 0:5) +
#   scale_color_manual('Groups', values = 
#                        c('#1b9e77','#d95f02','#7570b3',
#                          '#e7298a','#66a61e','#e6ab02') )
```

```{r ade4_plot, eval=FALSE, fig.width=10, cache=T, dpi=300, include=FALSE}
col <- funky(15)

s.class(pca.obj$li, pop(obj), xax=1, yax=2,
        col=transp(col,.6))
title("PCA \naxes 1-2")
add.scatter.eig(pca.obj$eig[1:20], nf=3,xax=1,yax=2)
```

### Correspondence Analysis
```{r ca, dpi=96, cache=T, fig.width=5, fig.height=3}
ca1 <- dudi.coa(tab(obj, freq = TRUE, NA.method = "mean"), scannf=FALSE,nf=3) 

fviz_eig(ca1, main = "Scree plot of CA")
```

```{r ca_plots, fig.width=10, dpi=300, cache=T}
# devtools::install_github('fawda123/ggord')

ggord(ca1, pop(obj), arrow = NULL, txt = NULL, 
      grp_title="Populations", ellipse=T, poly=FALSE, 
      size=2, alpha=.8, coord_fix=F, axes = c("1", "2")) +
  geom_hline(yintercept=0,linetype=2) + 
  geom_vline(xintercept=0,linetype=2) +
  ggtitle("Correspondence Analysis")  +
  scale_shape_manual('Groups', values = 0:5) +
  scale_color_manual('Groups', values = 
                       c('#1b9e77','#d95f02','#7570b3',
                         '#e7298a','#66a61e','#e6ab02') )

# ggord(ca1, pop(obj), arrow = NULL, txt = NULL, 
# grp_title="Populations", ellipse=T, poly=FALSE, 
# size=2, alpha=.8, coord_fix=F, axes = c("1", "3")) +
#   geom_hline(yintercept=0,linetype=2) + 
#   geom_vline(xintercept=0,linetype=2) +
#   ggtitle("Correspondence Analysis")
#   #scale_colour_brewer(palette="Set3")

# loadingplot(ca1$c1^2, threshold = 8)
```

### AMOVA
```{r amova, cache=T}
# setPop(obj) <- ~Country

poppr.amova(obj, ~Country, within = F)
```

### Hierarchical AMOVA
```{r amova_within, cache=T}
# setPop(obj) <- ~Country/Pop

poppr.amova(obj, ~Country/Pop, within = F)
```

### Hierarchical AMOVA - within variation included (as calculated using Arlequin)
```{r amova_arlequin, cache=T}
### Hierarchical AMOVA - within variation included (as calculated using Arlequin)
poppr.amova(obj, ~Country/Pop, within = T)
```

### IBD
```{r ibd, fig.height=5, fig.width=5, cache=T, dpi=300}

#change hierarchy to country level
setPop(obj) <- ~Country

# obj_pop <- genind2genpop(obj)
# Dgen <- dist.genpop(obj_pop,method=2) #maybe only with genepop object

# compute cavalli-sforza distance
Dgen <- genet.dist(obj, method = "Dch")
# theoretically any genetic distance can be used
# Dgeo <- dist(obj_pop$other$xy)
geo <- data.frame(popNames(obj))
x <- c(47.81, 40.09, 46.09)
y <- c(12.87, 22.44, 14.29)
geo$x <- x
geo$y <- y
Dgeo <- dist(geo)

ibd <- mantel.randtest(Dgen,Dgeo) 
ibd

# plot(ibd)

# library(MASS)
# dens <- kde2d(Dgeo,Dgen, n=300)
# myPal <- colorRampPalette(c("white","blue","gold", "orange", "red"))
# plot(Dgeo, Dgen, pch=20,cex=.5,
#      ylab="Cavalli-Sforza genetic distance",
#      xlab="Geographical distance (euclidean)")
# image(dens, col=transp(myPal(300),.7), add=TRUE)
# abline(lm(Dgen~Dgeo))
# title("Isolation by distance")

plot(Dgeo, Dgen, pch=20,cex=.5,
     ylab="Cavalli-Sforza genetic distance",
     xlab="Geographical distance (euclidean)")
abline(lm(Dgen~Dgeo))
title("Isolation by distance")

#reset hierarchy
setPop(obj) <- ~Country/Pop
```

```{r}
library(ecodist)

mantel(Dgen ~ Dgeo)
```


### Structure

#### 1000 Burn-in iterations, 5000 MCMC repititions
#### ATTN! A lower than optimal number of repititions was used, due to computational constrains.
#### Repeating the analysis using a higher number of repitions is required to ensure its robustness.
```{r}
#change hierarchy
setPop(obj) <- ~Country/Pop
```

```{r structure_runs, eval=FALSE, cache=T, include=T}

## Convert input file
        loci <- genind2loci(obj)
        
        ## obj_g <- genind2gtypes(obj)
        obj_g <- loci2gtypes(loci)

struct <- structureRun(obj_g, k = 2:6, num.k.rep = 5,
                            burnin = 1000, numreps = 5000, noadmix = F,
                            freqscorr = T, 
                            ## pop.prior = , 
                            ## locpriorinit = , maxlocprior = , ## locprior
                            ## gensback = , migrprior = , ## usepopinfo
                            ## pfrompopflagonly = , popflag = , ## usepopinfo
                            ## pops = c(""),
                            delete.files = F)

## ## Evanno deltaK
## evanno(gano.struct)
## 
## ## clumpp
## gano.clumpp <- clumpp(gano.struct, k=5, 
##                       delete.files = F)
## 
## ## show membership using strataG
## sp <- structurePlot(gano.clumpp, horiz = FALSE)



```

#### Tests for optimal K
```{r evanno, cache=T}
## read structure runs from pophelper
sfiles <- list.files(path = "../results/gtypes.created.on.2019.04.27.21.33.22.structureRun/",
                     pattern = "out_f", full.names = T, recursive = T)

        ## include individual names from STRUCTURE file as row names
slist <- readQ(files=sfiles, indlabfromfile=T)

## Evanno pophelper
sr1 <- summariseQ(tabulateQ(slist))
p <- evannoMethodStructure(data=sr1,exportplot=F,returnplot=T,
                           returndata=F,basesize=12,linesize=0.7)
```

```{r evanno2, cache=T, dpi=300, fig.width=10} 
grid.arrange(p)
```


```{r barplots-structure, dpi=300, cache=T, fig.width=10}
## clumpp through pophelper
## clumppExport(qlist=slist[16:20], useexe=T)

## show membership using pophelper
## read aligned file
## aligned <- readQ("./pop_K5/pop_K5-combined-aligned.txt")

## plot
## copy & paste the population column from genalex input file to a csv
# pop_labs <- read.delim("Castanea_SSR_HRM_pops.csv", 
#                        header=F,stringsAsFactors=F)

loci <- genind2loci(obj)

pop_labs <- data.frame(loci[,1], stringsAsFactors = F)
names(pop_labs) <- "Pop" 
pop_labs$Pop <- as.character(pop_labs$Pop)

## FOR MORE COLOR COMBINATIONS CHECK:
## http://colorbrewer2.org/##type=diverging&scheme=BrBG&n=4
clist <- list(
        "shiny"=c("#1D72F5","#DF0101","#77CE61", "#FF9326","#A945FF","#0089B2","#FDF060","#FFA6B2","#BFF217","#60D5FD","#CC1577","#F2B950","#7FB21D","#EC496F","#326397","#B26314","#027368","#A4A4A4","#610B5E"),
        "strong"=c("#11A4C8","#63C2C5","#1D4F9F","#0C516D","#2A2771","#396D35","#80C342","#725DA8","#B62025","#ED2224","#ED1943","#ED3995","#7E277C","#F7EC16","#F8941E","#8C2A1C","#808080"),
        "oceanfive"=c("#00A0B0", "#6A4A3C", "#CC333F", "#EB6841", "#EDC951"),
        "keeled"=c("#48B098", "#91CB62", "#FFEE3B", "#FB9013", "#FF3C28"),
        "vintage"=c("#400F13", "#027368", "#A3BF3F", "#F2B950", "#D93A2B"),
        "muted"=c("#46BDDD","#82DDCE","#F5F06A","#F5CC6A","#F57E6A"),
        "teal"=c("#CFF09E","#A8DBA8","#79BD9A","#3B8686","#0B486B"),
        "merry"=c("#5BC0EB","#FDE74C","#9BC53D","#E55934","#FA7921"),
        "funky"=c("#A6CEE3", "#3F8EAA", "#79C360", "#E52829", "#FDB762","#ED8F47","#9471B4"),
        "retro"=c("#01948E","#A9C4E2","#E23560","#01A7B3","#FDA963","#323665","#EC687D"),
        "cb_paired"=c("#A6CEE3","#1F78B4","#B2DF8A","#33A02C","#FB9A99","#E31A1C","#FDBF6F","#FF7F00","#CAB2D6","#6A3D9A","#FFFF99","#B15928"),
        "cb_set3"=c("#8DD3C7","#FFFFB3","#BEBADA","#FB8072","#80B1D3","#FDB462","#B3DE69","#FCCDE5","#D9D9D9","#BC80BD","#CCEBC5","#FFED6F"),
        "morris"=c("#4D94CC","#34648A","#8B658A","#9ACD32","#CC95CC","#9ACD32","#8B3A39","#CD6601","#CC5C5B","#8A4500"),
        "wong"=c("#000000","#E69F00","#56B4E9","#009E73","#F0E442","#006699","#D55E00","#CC79A7"),
        "krzywinski"=c("#006E82","#8214A0","#005AC8","#00A0FA","#FA78FA","#14D2DC","#AA0A3C","#FA7850","#0AB45A","#F0F032","#A0FA82","#FAE6BE"))

p2 <- plotQ(slist[1],returnplot=T,exportplot=F,quiet=T,basesize=11,
            # showindlab=T, useindlab=T, 
            ## indlabwithgrplab=T,
            showsp = T, splab = "K=2", splabsize = 11,
            showyaxis=T, 
            # showticks=T, ticksize=0.3, ticklength=0.2 ## y axis
            ,panelspacer=0.4,
            grplab = pop_labs,
            grplabsize=4, linesize=0.8, pointsize=4,
            ## sortind="all",
            divgrp = "Pop", divsize=0.5,
            clustercol=clist$wong,
            panelratio=c(11,1))

## grid.arrange(p2$plot[[1]])

p3 <- plotQ(slist[6],returnplot=T,exportplot=F,quiet=T,basesize=11,
            # showindlab=T, useindlab=T, 
            ## indlabwithgrplab=T,
            showsp = T, splab = "K=3", splabsize = 11,
            showyaxis=T, 
            # showticks=T, ticksize=0.3, ticklength=0.2 ## y axis
            ,panelspacer=0.4,
            grplab = pop_labs,
            grplabsize=4, linesize=0.8, pointsize=4,
            ## sortind="all",
            divgrp = "Pop", divsize=0.5,
            clustercol=clist$wong,
            panelratio=c(11,1))

## grid.arrange(p3$plot[[1]])
```

```{r barplots-structure2, cache=T}
## A new chunk was created for plotting to avoid producing an empty plot
## https://support.rstudio.com/hc/en-us/community/posts/239529128-Notebooks-grid-newpage
grid.arrange(p2$plot[[1]])
grid.arrange(p3$plot[[1]])
```

```{r}
#reset hierarchy
setPop(obj) <- ~Country/Pop
```


# Ne estimation
Estimate Ne from linkage disequilibrium based on Pearson correlation approximation following [@waples_EstimatingContemporaryEffective_2016].

ATTN! Check if some loci should be removed in case of LD
```{r}
## Convert input file
        loci <- genind2loci(obj)
        
        ## obj_g <- genind2gtypes(obj)
        obj_g <- loci2gtypes(loci)
```        

```{r}
#' @title ldNe
#' @description Estimate Ne from linkage disequilibrium based on Pearson 
#'   correlation approximation following Waples et al 2016. Adapted from code 
#'   by R. Waples and W. Larson.
#'
#' @param g a \linkS4class{gtypes} object.
#' @param maf.threshold smallest minimum allele frequency permitted to include 
#'   a locus in calculation of Ne.
#' @param by.strata apply the \code{maf.threshold} by strata. If \code{TRUE}
#'   then any locus that is below this threshold in any strata will be removed 
#'   from the calculation of Ne for every stratum. Otherwise, loci are removed 
#'   only if they are below the \code{maf.threshold} in the stratum for which 
#'   Ne is calculated.
#' @param ci central confidence interval.
#'
#' @return a numeric matrix with one row per strata and the following columns:
#' \describe{
#'  \item{\code{S}}{harmonic mean of sample size across pairwise comparisons of loci}
#'  \item{\code{num.comp}}{number of pairwise loci comparisons used}
#'  \item{\code{mean.rsq}}{mean r^2 over all loci}
#'  \item{\code{mean.E.rsq}}{mean expected r^2 over all loci}
#'  \item{\code{Ne}}{estimated Ne}
#'  \item{\code{param.lci, param.uci}}{parametric lower and upper CIs}
#' }
#' 
#' @references Waples, R.S. 2006. A bias correction for estimates of effective population 
#'   size based on linkage disequilibrium at unlinked gene loci. 
#'   Conservation Genetics 7:167-184. \cr\cr
#'   Waples RK, Larson WA, and Waples RS. 2016. Estimating contemporary 
#'   effective population size in non-model species using linkage 
#'   disequilibrium across thousands of loci. Heredity 117:233-240; 
#'   doi:10.1038/hdy.2016.60
#'
#' @author Eric Archer \email{eric.archer@@noaa.gov}
#' 
#' @importFrom parallel mclapply detectCores
#' @importFrom stats cor qchisq
#' @export
#' 
ldNe <- function(g, maf.threshold = 0, by.strata = FALSE, ci = 0.95) {
  if(ploidy(g) != 2) stop("'g' must have diploid data")
  
  # remove non-biallelic loci
  num.alleles <- numAlleles(g)
  biallelic <- names(num.alleles)[num.alleles <= 2]
  if(length(biallelic) == 0) {
    warning("No loci are biallelic. NULL returned.", call. = FALSE)
    return(NULL)
  }
  g <- g[, biallelic, ]
  
  # remove loci if below maf threshold for any stratum
  if(maf.threshold > 0 & by.strata) {
    maf.g <- maf(g, by.strata = TRUE)
    above.thresh <- which(apply(maf.g, 2, function(x) all(x >= maf.threshold)))
    if(length(above.thresh) < 2) {
      warning(
        paste0("Fewer than two loci are above 'maf.threshold' in any stratum. NULL returned."),
        call. = FALSE
      )
      return(NULL)
    }
    g <- g[, above.thresh, ]
  }
  
  # calculate Pearson r-squared between a pair of loci
  compLoc <- function(i, loc.pairs, mat) {
    pair.mat <- mat[, loc.pairs[, i]]
    pair.mat <- pair.mat[complete.cases(pair.mat), , drop = FALSE]
    rsq <- cor(pair.mat[, 1], pair.mat[, 2], method = "pearson") ^ 2
    S <- nrow(pair.mat)
    c(S = S, rsq = rsq)
  }
  
  # Eqn 1.7: calculate Ne
  calcNe <- function(S, Rsq.drift) {
    if(S > 29) {
      root.term <- 1 / 9 - 2.76 * Rsq.drift
      if(root.term < 0) root.term <- 0
      (1 / 3 + sqrt(root.term)) / (2 * Rsq.drift)
    } else {
      root.term <- 0.308 ^ 2 - 2.08 * Rsq.drift
      if(root.term < 0) root.term <- 0
      (0.308 + sqrt(root.term)) / (2 * Rsq.drift)
    }
  }
  
  # calculate Ne by strata
  ne.smry <- sapply(strataSplit(g), function(g.st) {
    # remove loci below MAF threshold
    if(maf.threshold > 0) {
      above.thresh <- which(maf(g.st) >= maf.threshold)
      if(length(above.thresh) < 2) {
        warning(
          paste0("Fewer than two loci are above 'maf.threshold' in '", strataNames(g.st), "'"),
          call. = FALSE
        )
        return(NULL)
      }
      g.st <- g.st[, above.thresh, ]
    }
    
    # create list of coded numeric matrices for each stratum
    g.mat <- as.matrix(g.st, ids = FALSE, strata = FALSE)
    mat <- matrix(nrow = nInd(g.st), ncol = nLoc(g.st))
    a1.i <- seq(1, ncol(g.mat), by = 2)
    for(j in 1:length(a1.i)) {
      a1 <- a1.i[j]
      mat.j <- g.mat[, c(a1, a1 + 1), drop = FALSE]
      alleles <- sort(unique(mat.j))
      for(i in 1:nrow(mat.j)) mat[i, j] <- sum(mat.j[i, ] == alleles[1])
    }
    
    # remove loci that are constant
    mat <- mat[, apply(mat, 2, function(x) var(x) > 0), drop = FALSE]
    if(ncol(mat) < 2) {
      warning(
        paste0("Fewer than two loci have more than one genotype in '", strataNames(g.st), "'"),
        call. = FALSE
      )
      return(NULL)
    }
    
    # calculate correlation r-squared (rsq) between pairs of loci
    loc.pairs <- combn(ncol(mat), 2)
    loc.comp.mat <- mclapply(1:ncol(loc.pairs), compLoc, loc.pairs = loc.pairs, mat = mat, mc.cores = detectCores() - 1)
    loc.comp.mat <- do.call(cbind, loc.comp.mat)
    to.keep <- apply(loc.comp.mat, 2, function(x) all(!is.na(x)))
    if(sum(to.keep) == 0) stop("all loci have missing data")
    loc.comp.mat <- loc.comp.mat[, to.keep, drop = FALSE]
    
    # cl <- .setupClusters()
    # loc.comp.mat <- tryCatch({
    #   if(!is.null(cl)) {
    #     parSapply(cl, 1:ncol(loc.pairs), compLoc, loc.pairs = loc.pairs, mat = mat)
    #   } else {
    #     sapply(1:ncol(loc.pairs), compLoc, loc.pairs = loc.pairs, mat = mat)
    #   }
    # }, finally = if(!is.null(cl)) stopCluster(cl))
    
    S <- loc.comp.mat["S", ]
    # Eqn 1.1: expected r-squared
    E.rsq <- ifelse(S > 29, (1 / S) + (3.19 / S ^ 2), 0.0018 + (0.907 / S) + (4.44 / S ^ 2))
    # sample size corrected r-squared
    rsq <- loc.comp.mat["rsq", ] * ((S / (S - 1)) ^ 2)
    # Eqn 1.4
    w <- S ^ 2
    # Eqn 1.5
    W <- sum(w)
    mean.rsq <- sum(w * rsq) / W
    # Eqn 1.6
    Rsq.drift <- rsq - E.rsq
    # Eqn 1.10: R-squared prime.0 for Ne.0 
    Rsq.drift.0 <- sum(Rsq.drift * w) / W
    # harmonic mean of S
    N <- ncol(loc.comp.mat)
    S.harm.mean <- N / sum(1 / S)
    # initial Ne.0
    ne0 <- calcNe(S.harm.mean, Rsq.drift.0)
    
    # Eqn 1.11: R-squared prime weights
    wt <- S ^ 2 / (S + 3 * ne0) ^ 2
    # Eqn 1.12: weighted R-squared prime
    Rsq.drift <- sum(wt * Rsq.drift) / sum(wt)
    
    # mean expected r-squared
    mean.E.rsq <- sum(w * E.rsq) / W
    
    # calculate CI
    lci.p <- (1 - ci) / 2
    uci.p <- 1 - lci.p
    Rsq.drift.lci <- mean.rsq * N / qchisq(lci.p, N) - mean.E.rsq
    Rsq.drift.uci <- mean.rsq * N / qchisq(uci.p, N) - mean.E.rsq
    
    ne <- calcNe(S.harm.mean, Rsq.drift)
    param.lci <- calcNe(S.harm.mean, Rsq.drift.lci)
    param.uci <- calcNe(S.harm.mean, Rsq.drift.uci)
    if(ne < 0) ne <- Inf
    if(param.lci < 0) param.lci <- Inf
    if(param.uci < 0) param.uci <- Inf
    
    c(
      S = S.harm.mean, num.comp = N, mean.rsq = mean.rsq, 
      mean.E.rsq = mean.E.rsq, Ne = ne, param.lci = param.lci, 
      param.uci = param.uci
    )
  }, USE.NAMES = TRUE, simplify = FALSE)
  ne.smry <- ne.smry[!sapply(ne.smry, is.null)]
  do.call(rbind, ne.smry)
}
```

```{r}
library(parallel)

Ne_0 <- ldNe(obj_g, maf.threshold = 0, by.strata = F, ci = 0.95)
Ne_0 <- as.data.frame(Ne_0)

Ne_0 <- add_column(Ne_0, population = popNames(obj), .before = "S")
Ne_0
```

```{r}
Ne_0.05 <- ldNe(obj_g, maf.threshold = 0.01, by.strata = F, ci = 0.95)
Ne_0.05 <- as.data.frame(Ne_0.05)

Ne_0.05 <- add_column(Ne_0.05, population = popNames(obj), .before = "S")
Ne_0.05
```

```{r}
knitr::kable(Ne_0, format = "html", digits = 3) %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)

# ggplot(Ne, aes(x=population, y=Ne)) +
#   geom_point(stat = "identity", 
#            color="black", fill = "lightgrey",
#            size = 2) +
#   scale_y_continuous(breaks = seq(0, 10000, 500)) +
#   geom_errorbar(aes(ymin=param.lci, ymax=param.uci),
#                 width = .3) +
#   ggtitle("Ne (95% CIs)") +
#   theme_classic()
```

```{r}
library(parallel)

ldNe(obj_g,maf.threshold = 0, by.strata = F, ci = 0.95)
```

```{r}
to.remove <- as.vector(LD_sig_intersect$locus1[-3])

loci_int <- names(nAll(obj))

obj_no_LD <- obj[,loc = setdiff(loci_int, to.remove)]
```

```{r}
# Convert input file
        loci_no_LD <- genind2loci(obj_no_LD)
        
        ## obj_g <- genind2gtypes(obj)
        obj_g_no_LD <- loci2gtypes(loci_no_LD)
```

```{r}
Ne_0_no_LD <- ldNe(obj_g_no_LD, maf.threshold = 0, by.strata = F, ci = 0.95)
Ne_0_no_LD <- as.data.frame(Ne_0_no_LD)

Ne_0_no_LD <- add_column(Ne_0_no_LD, population = popNames(obj), .before = "S")
Ne_0_no_LD
```

### NeEstimator


# Notes

- Some SNPs are only typed for the greek populations, and were not included in this
analysis. They should be investigated further.

# Reproducibility
```{r reproducibility}
devtools::session_info()
```

# Bibliography