---
title: "LifeGenMon Abies SNP analysis"
author: "Nikos Tourvas"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
bibliography: library.bib
output:
  html_document:
    code_folding: hide
    theme: united
    toc: yes
    ## toc_float: yes
  html_notebook:
    code_folding: hide
    theme: united
    toc: yes
    toc_float: yes
    toc_depth: 3
  pdf_document:
    toc: yes
always_allow_html: yes
---

```{r libraries, echo=TRUE}
# suppressPackageStartupMessages({
  library(adegenet)
  library(popprxl)
  library(hierfstat)
  library(magrittr)
  library(pegas)
  ## library(genepop)
  library(mmod)
  library(ape)
  library(phangorn)
  library(tidyverse)
  library(reshape2)
  library(strataG)
  library(ggplot2)
  library(lattice)
  library(factoextra)
  library(ggord)
  library(RColorBrewer)
  ## library(ggcompoplot)
  library(kableExtra)
  library(pophelper)
  library(gridExtra)
# })
```

```{r}
# library(readr)
# snp <- read_csv("data/Genotyping-1841.025-03 Grid_EDITED.csv", 
#     na = c("?", "Uncallable", "Bad") )
# 
# snp
```


# Import csv
```{r import_csv}
snp <- read.csv("data/Genotyping-1841.025-03 Grid_reformated.csv", 
                header = T, 
                na.strings = c("?", "Uncallable", "Bad")
               # ,stringsAsFactors = T
               , check.names = F # default is TRUE, and changes the dashes to dots - which created problems
               )
# snp
```


## Transform sample names
#### This will allow hierarchical analysis when applicable
#### Country / Species / Pop / Plot
```{r}
snp <- snp %>% 
  mutate(Genotype = str_replace_all(Genotype, "^AB", "GR_AB_A_")) %>% #GR_Adult
  mutate(Genotype = str_replace_all(Genotype, "^RAB", "GR_AB")) %>% #GR_Regen
  
  mutate(Genotype = str_replace_all(Genotype, "_A_", "_A_1_")) %>% 
  
  mutate(Genotype = str_replace_all(Genotype, "NR", "NR_"))
```


## Remove samples that consistently do not amplify
```{r remove_bad}
# 
# snp_fil <- snp %>% 
#         filter(snpa != "Bad")
# 
# snp_fil
```

### Create a df following the guidelines of the loci format
```{r}
snp_loci_format <- as.data.frame(sapply(snp, gsub, pattern=':', replacement='/') )
# snp_loci_format <- as.data.frame(sapply(snp_loci_format, gsub, pattern=".", replacement="_"))
snp_loci_format <- snp_loci_format[,-1]
rownames(snp_loci_format) <- snp[,1]

snp_loci_format
```

## Add a second column for population
```{r}

pop1 <- replicate(124, "DE_AAL_A_1")
pop2 <- replicate(16, "DE_AAL_NR_1")
pop3 <- replicate(16, "DE_AAL_NR_2")
pop4 <- replicate(16, "DE_AAL_NR_3")
pop5 <- replicate(16, "DE_AAL_NR_4")
pop6 <- replicate(124, "GR_AB_A_1")
pop7 <- replicate(20, "GR_AB_NR_1")
pop8 <- replicate(18, "GR_AB_NR_2")
pop9 <- replicate(16, "GR_AB_NR_3")
pop10 <- replicate(10, "GR_AB_NR_4")
pop11 <- replicate(124, "SI_AAL_A_1")
pop12 <- replicate(16, "SI_AAL_NR_1")
pop13 <- replicate(16, "SI_AAL_NR_2")
pop14 <- replicate(16, "SI_AAL_NR_3")
pop15 <- replicate(16, "SI_AAL_NR_4")

pop <- c(pop1, pop2, pop3, pop4, pop5, pop6,
         pop7, pop8, pop9, pop10, pop11,
         pop12, pop13, pop14, pop15)

# pop

snp_loci_format <- add_column(snp_loci_format, pop, .before = "contig00241-160")

snp_loci_format
```

## Create genind object
```{r}
library(pegas)

data <- as.loci(snp_loci_format, 
                col.pop = 1
                ,allele.sep = "/")
# data

obj_origin <- loci2genind(data,)
obj_origin
```

### stratify data set
```{r test}
strata_df <- as.data.frame(snp_loci_format$pop)
colnames(strata_df) <- "strata"
strata_df <- separate(strata_df, col = strata, sep="_", 
                      into = c("Country", 
                               "Species", 
                               "Pop", 
                               "Plot"))
strata(obj_origin) <- strata_df

setPop(obj_origin) <- ~Country/Pop
obj_origin
```

# Data filtering

### Check for missing data
```{r missing, cache=F, fig.width=10, dpi=300}
capture.output(
info_table(obj_origin, type = "missing", plot = TRUE, plotlab = F),
file='NUL') 
## capture.output is used to hide printing of the table on the console

div <- summary(obj_origin)

# paste("Total missing data is",  round(div$NA.perc, digits = 2), "%", sep = " ")
```

### Percent (%) of missing data by pop
```{r missing_by_pop}
library(purrr)
missing_by_pop <- as.data.frame(
  seppop(obj_origin) %>% 
  lapply(adegenet::summary) %>% 
  map_depth(1, "NA.perc")
)

knitr::kable(missing_by_pop, digits = 2, format = "html") %>% 
  kable_styling(bootstrap_options = "striped", full_width = F)
```

### How many loci are biallelic?
```{r fig.height=3, fig.width=3, cache=T, dpi=300}
alleles_per_locus <- nAll(obj_origin)

number_df <- as.data.frame(alleles_per_locus)

ggplot(number_df, aes(x=alleles_per_locus) ) +
  geom_bar(color="black", fill="white",
           width = 0.5) +
  scale_x_continuous(breaks = c(1,2,3,4))

perc_bi <- number_df %>% 
  group_by(alleles_per_locus) %>% 
  count() %>% 
  mutate("percent_(%)" = round(n / nLoc(obj_origin) * 100,  digits = 2))%>% 
  rename("alleles per locus" = alleles_per_locus,
         occurences = n,
         "occurences (%)" = "percent_(%)")


knitr::kable(perc_bi, "html", digits = 2) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
```

### Remove uninformative (monomorphic) loci
```{r maf}
obj <- informloci(obj_origin, MAF = 0)
```

### Filter out missing data
```{r missing2, cache=F, fig.width=10, dpi=300}
obj <- missingno(obj, type = "loci", cutoff = 0.10)

obj <- missingno(obj, type = "genotypes", cutoff = 0.15)

test <- seppop(obj) %>% 
  lapply(propTyped, by="loc") %>% 
  lapply(sort)

capture.output(
info_table(obj, type = "missing", plot = TRUE, plotlab = F),
file='NUL')
```

# Summary statistics
```{r summary_statistics, cache=T}

## functions

###### basic statistics and their SEs
table_out <- function(obj, variable, name){
  
means <- colMeans(variable, na.rm=T)
out <- c(means, mean(variable, na.rm = T))

out <- as.data.frame(out)
Pops <- c(popNames(obj), "Total")
rownames(out) <- Pops
colnames(out) <- name

sem_out <- apply(variable, 2, function(x) sd(x) / sqrt(length(x))) 
  ## 2 means work along columns
sem_out_mean <- sd(variable) / sqrt(length(variable))

sem_out <- as.data.frame(c(sem_out, sem_out_mean))
rownames(sem_out) <- Pops
colnames(sem_out) <- paste("SE", name, sep = "_")

table_out <- cbind(out, sem_out)

return(table_out)
}




###### basic statistics reported from poppr and their SEs
poppr2hierfstat_out <- function(obj, variable){
  
obj_list <- seppop(obj)
  
stats_poppr <- list()
for(i in 1: length(obj_list)){
  stats_poppr[[i]] <- locus_table(obj_list[[i]], information = F)
}

table_out <- list()
for(i in 1:length(obj_list))
table_out[[i]] <- stats_poppr[[i]][-nrow(stats_poppr[[1]]), variable]

table_out <- as.matrix(as.data.frame(table_out))
colnames(table_out) <- popNames(obj)

return(table_out)
}

```

```{r}
## N
N_by_locus <- basic.stats(obj)[["n.ind.samp"]]
obj_list <- seppop(obj)
N <- list()
for(i in 1:length(obj_list)){
        N[[i]] <- length(obj_list[[i]]@pop)
}
N <- melt(N)
N <- c(N[,1], sum(N[,1]))

## na
na_by_locus <- poppr2hierfstat_out(obj, "allele")
na <- table_out(obj, na_by_locus, "na")


## uHe
uHe_by_locus <- poppr2hierfstat_out(obj, "Hexp")
uHe <- table_out(obj, uHe_by_locus, "uHe")

## Ho
Ho_by_locus <- basic.stats(obj)[["Ho"]]
Ho <- table_out(obj, Ho_by_locus, "Ho")

## ne
ne_by_locus_Hs <- 1 / (1 - (basic.stats(obj)[["Hs"]]))
ne_Hs <- table_out(obj, ne_by_locus_Hs, "ne")

## ## ne
## ne_by_locus_He <- 1 / (1 - (basic.stats(obj)[["Hs"]]))
## ne_Hs <- table_out(obj, ne_by_locus, "ne")

## Fis
Fis_by_locus <- basic.stats(obj)[["Fis"]]
Fis <- table_out(obj, Fis_by_locus, "Fis") ## better use boot.ppfis
boot.fis <- boot.ppfis(obj, nboot=1000)
```

```{r}
# test <- snp_loci_format[1:300,]
#   # filter(pop == "GR_Adult" )
# 
# data_adult <- as.loci(test, col.pop = 1, allele.sep = "/")
# 
# obj_gr_adult <- loci2genind(data_adult,)
# 
# # obj_gr_adult <- informloci(obj_gr_adult, MAF = 0)
# 
# obj_gr_adult
# 
# fistest <- basic.stats(obj_gr_adult)
```

```{r SummaryTable, cache=T}
summary_df <- cbind(N, na[,1], ne_Hs[,1], Ho[,1], uHe[,1])
rownames(summary_df) <- c(popNames(obj), "Total")
colnames(summary_df) <- c("N", "na", "ne", "Ho", "uHe")
summary_df <- round(as.data.frame(summary_df), digits = 3)

knitr::kable(summary_df, "html", digits = 2) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)

## summary_df2 <- cbind(N, na, ne_Hs, Ho, uHe)
## summary_df2
```

```{r}
uHe <- uHe %>% 
  mutate(upper = uHe + 2 * SE_uHe) %>% 
  mutate(lower = uHe - 2 * SE_uHe) %>% 
  add_column(population = c(popNames(obj), "Total") )
```

```{r fig.height=3, fig.width=5}
uHe[-nrow(uHe),] %>% 
ggplot(aes(x=population, y=uHe)) +
  geom_bar(stat = "identity", 
           color="black", fill = "lightgrey",
           width = .6) +
  scale_y_continuous(breaks = seq(0, 0.3, 0.05)) +
  geom_errorbar(aes(ymin=lower, ymax=upper),
                width = .3) +
  ggtitle("uHe and 95% CIs") +
  theme_classic()
```

### Total Number of alleles per population
```{r cache=T, dpi=300, fig.width=5, fig.height=3}
div <- summary(obj)

all <- as.data.frame(div$pop.n.all)
all <- all %>% 
  mutate(population = rownames(all)) %>% 
  rename(count = "div$pop.n.all")

all$count <- as.integer(all$count)

# str(all)

ggplot(all, aes(x=population, y=count) ) +
  geom_bar(stat = "identity", 
           color = "black", fill = "white",
           width = .8) +
  geom_text(aes(label=count, vjust = 1.6)) +
  ggtitle("Total Number of alleles per population")
```

### F~IS~ (95% CIs)
```{r Fis, cache=T}
# test <- unlist(obj_list)
# 
# test <- lapply(obj_list, genind2hierfstat)
# test2 <- lapply(test, basic.stats, na.omit=T)
# 
# for(i in 1:length(obj_list)){
#   test[[i]] <- basic.stats(obj_list[[i]])
# }
# 
# basic.stats(obj_list[[1]])[["Fis"]]
# 
# test <- basic.stats(obj)

fis <- boot.ppfis(obj)
rownames(fis[["fis.ci"]]) <- levels(obj@pop)
fis
```

### Private alleles per population
```{r private_pops, cache=TRUE, dpi=300, fig.width=8.5}
private <- private_alleles(obj, report = "data.frame")
private
# ggplot(private) + geom_tile(aes(x = population, 
#                                 y = allele, 
#                                 fill = count)) +
#   ggtitle("Private alleles per population") +
#   scale_fill_viridis_c()
```


```{r LD_r, eval=FALSE, fig.height=10, dpi=300, include=FALSE}
### LD
# Index of association

rd <- seppop(obj) %>% lapply(pair.ia, plot = F, quiet = T)
# seppop: separates dataset by pop

# Consistent range in the plotted graphics
plotrange <- range(rd, na.rm = TRUE)
# Re-plot the graphics
rd <- seppop(obj) %>% 
  lapply(pair.ia, limits = plotrange, quiet = T)
```

### Hardy - Weinberg equilibrium
```{r HWE, fig.width=9, fig.height=20, dpi=300, cache=TRUE}
hw.obj <- seppop(obj, drop=T) %>% 
  lapply(hw.test, B = 0)
## seppop: calculates p-value for each locus of every pop
## B: number of permutations

## Isolate p-values either from chi2 test (j=3) or 
## from exact test (j=4)
hw.mat <- sapply(hw.obj, "[", i = TRUE, j = 3)
## Take the third/fourth column with all rows

## Multiple test correction (Holm-Bonferroni)
hw.holm.values <- p.adjust(hw.mat, method = "holm")
locinames <- rownames(hw.mat)
popnames <- colnames(hw.mat)

hw.holm.mat <- matrix(nrow = length(locNames(obj)),
                      ncol = length(popNames(obj)),
                      data = hw.holm.values, byrow = F)
rownames(hw.holm.mat) <- locinames
colnames(hw.holm.mat) <- popnames

levelplot(t(hw.holm.mat), aspect = "fill", xlab="Pop", ylab="Marker", 
          main = "HWE chi^2 p-values after Holm-Bonferroni correction")

## kable(hw.holm.mat, "html", 
## caption = "HWE exact test p-values after Holm-Bonferroni 
## correction (1000 permutations)") %>% 
##  kable_styling(bootstrap_options = "striped", full_width = F)
```

# Genetic Differentiation
```{r matrix_fun}
## Get lower triangle of the matrix 
  get_lower_tri<-function(matrix){
    matrix[upper.tri(matrix, diag = T)] <- NA
    matrix <- matrix[-1, -ncol(matrix)]
    return(matrix)
  }
```

### F~ST~ (G~ST~) [@nei_MolecularEvolutionaryGenetics_1987]
```{r Fst_table, cache=T}
library(hierfstat)
pair_fst <- genet.dist(obj, method = "Nei87")
pair_fst <- as.data.frame(as.matrix(pair_fst))
  
## print table with knitr  
pair_fst <- get_lower_tri(pair_fst)  
options(knitr.kable.NA = '')  


knitr::kable(pair_fst, "html", digits = 4) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
```

### Nm based on F~ST~ (G~ST~) [@nei_MolecularEvolutionaryGenetics_1987]
#### ATTN: Results differ from GenAlEx, as this calculates Nm based on the original F~ST~
```{r}
x <- basic.stats(obj)
Nm <- ( (1 / x[["perloc"]][["Fst"]]) - 1) / 4

Nm_mean <- mean(Nm)

Nm_se <- sd(Nm) / sqrt(length(Nm))

Nm_df <- data.frame(
        Nm = round (Nm_mean, digits=2),
        se = round( Nm_se, digits = 2)
)

knitr::kable(Nm_df, "html", digits = 4) %>% 
        kable_styling(bootstrap_options = "striped", full_width = F)
```

### Cavalli-Sforza and Edwards Chord distance [@cavalli-sforza_PhylogeneticAnalysisModels_1967]
```{r cavalli-sforza_1, fig.width = 10, dpi=300, cache=T}
## https://groups.google.com/forum/##!topic/poppr/vEQ8vb2oObQ

## create hierfstat input file
obj_hier <- genind2hierfstat(obj)

## create cav-sf distance table
cav_sf <- genet.dist(obj_hier, method = "Dch")
cav_sf <- as.matrix(cav_sf)
pop_vector <- popNames(obj)
colnames(cav_sf) <- pop_vector
rownames(cav_sf) <- pop_vector

## print table with knitr  
cav_sf <- get_lower_tri(cav_sf)  
options(knitr.kable.NA = '')  
knitr::kable(cav_sf, "html", digits = 4,
  caption = "Cavalli-Sforza and Edwards Chord distance between populations") %>% 
  
kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r cavalli-sforza_2, fig.width = 10, dpi=300, cache=T}
# functions
fungen <- function(pop_column) {
  force(pop_column)
  function(x) {
    dat <- cbind(pop_column, x)
    res <- nj(genet.dist(dat, method = "Dch"))
    res$tip.label <- levels(dat[[1]])
    res
  }
}

genet.tree.nj <- fungen(obj_hier[1])

fungen <- function(pop_column) {
  force(pop_column)
  function(x) {
    dat <- cbind(pop_column, x)
    res <- upgma(genet.dist(dat, method = "Dch"))
    res$tip.label <- levels(dat[[1]])
    res
  }
}

genet.tree.upgma <- fungen(obj_hier[1])
```


```{r fig.width = 10, dpi=300, cache=T}
# Create tree
tree_upgma <- genet.tree.upgma(obj_hier[-1])
num_boot <- 100
tree_upgma$node.label <- boot.phylo(phy = tree_upgma, x = obj_hier[-1],
                                    FUN = genet.tree.upgma, B = num_boot
                                    , jumble = FALSE
                                    , mc.cores = 4  # does not work on Windows
                                    )
```

```{r fig.width = 10, dpi=300, cache=T}
# Display tree
nodelabs <- (100 / num_boot) *  tree_upgma$node.label
nodelabs[nodelabs < 50] <- NA
plot.phylo(tree_upgma, cex = 1, font = 2, adj = 0, xpd = TRUE,
           label.offset = 0.0001)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8,
           font = 3, xpd = TRUE)
title(main = "Dendrogram based on Cavalli-Sforza and Edwards Chord distance",
      sub = "method: UPGMA, 1000 Bootstraps")
axisPhylo(side = 1)
```

```{r fig.width = 10, dpi=300, cache=T}
# Create tree
tree_nj <- genet.tree.nj(obj_hier[-1])
num_boot <- 100 # number of bootstraps
tree_nj$node.label <- boot.phylo(phy = tree_nj, x = obj_hier[-1], 
                                 FUN = genet.tree.nj, B = num_boot
                                 , jumble = FALSE
                                 , mc.cores = 4  # does not work on Windows
)
```

```{r fig.width = 10, dpi=300, cache=T}
# Display tree
nodelabs <- (100 / num_boot) *  tree_nj$node.label
nodelabs[nodelabs < 50] <- NA # hide values below 50
plot.phylo(tree_nj, cex = 1, font = 2, adj = 0, xpd = TRUE, 
           label.offset = 0.0001, type = "phylogram")
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
           font = 3, xpd = TRUE)
title(main = "Dendrogram based on Cavalli-Sforza and Edwards Chord distance",
      sub = "method: Neighbor-Joining, 1000 Bootstraps")
add.scale.bar(lwd = 2, length = 0.005, x = 0.01, y=1)
# to find optimal position for scale bar write on the console:
# locator(1)
# and click on the plot where you want to place the scale bar
```

### Nei distance [@nei_EstimationAverageHeterozygosity_1978]
```{r nei_hierfstat, cache=T}
## create nei distance table
nei <- genet.dist(obj, method = "Ds")
nei <- as.matrix(nei)
pop_vector <- popNames(obj)
colnames(nei) <- pop_vector
rownames(nei) <- pop_vector


## print table with knitr  
nei <- get_lower_tri(nei)
options(knitr.kable.NA = '')  
kable(nei, "html", digits = 4,
      caption = "Nei's Standard genetic distance between populations") %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r nei_poppr, fig.width = 10, dpi=300, cache=T}
set.seed(1994)


tree_upgma <- aboot(obj, strata = ~Country/Pop, sample = 1000, 
                    cutoff = 50, distance = "nei.dist", 
                    tree = "upgma",showtree = F)
```

```{r fig.width = 10, dpi=300, cache=T}
nodelabs <- round(tree_upgma$node.label, 2)
plot.phylo(tree_upgma, cex = 1, font = 2, adj = 0, xpd = TRUE, 
label.offset = 0.0001)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
font = 3, xpd = TRUE)
title(main = "Dendrogram based on Nei's standard genetic distance",
      sub = "method: UPGMA, 1000 Bootstraps")
axisPhylo(side = 1)
```

```{r fig.width = 10, dpi=300, cache=T}
tree_nj <- aboot(obj, strata = ~Country/Pop, sample = 1000, cutoff = 50,
                 distance = "nei.dist", tree = "nj", showtree = F)
```

```{r fig.width = 10, dpi=300, cache=T}
nodelabs <- round(tree_nj$node.label, 2)
plot.phylo(tree_nj, cex = 1, font = 2, adj = 0, xpd = TRUE, 
label.offset = 0.0001)
nodelabels(nodelabs, adj = c(1.3, -0.5), frame = "n", cex = 0.8, 
font = 3, xpd = TRUE)
title(main = "Dendrogram based on Nei's standard genetic distance",
      sub = "method: Neighbor-Joining, 1000 Bootstraps")
add.scale.bar(lwd = 2, length = 0.01, x = 0.24, y=1)
```

### Principal Component Analysis (PCA)
```{r pca, dpi=96, cache=T, fig.width=5, fig.height=3}
## In case there are missing data, replace with mean
X <- tab(obj, freq = TRUE, NA.method = "mean") 

pca.obj <- dudi.pca(X, scale = FALSE, scannf = FALSE, nf = 3)

fviz_eig(pca.obj, main = "Scree plot of PCA")
```

```{r pca_plots, fig.width=10, dpi=300, cache=T}
ggord(pca.obj, pop(obj), arrow = NULL, txt = NULL, 
      grp_title="Populations", ellipse=T, poly=FALSE, size=2, 
      alpha=.8, coord_fix=F, axes = c("1", "2")) +
  geom_hline(yintercept=0,linetype=2) + 
  geom_vline(xintercept=0,linetype=2) +
  ggtitle("Principal Component Analysis") +
  scale_shape_manual('Groups', values = 0:5) +
  scale_color_manual('Groups', values = 
                       c('#1b9e77','#d95f02','#7570b3',
                         '#e7298a','#66a61e','#e6ab02') )

# ggord(pca.obj, pop(obj), arrow = NULL, txt = NULL, 
# grp_title="Populations", ellipse=T, poly=FALSE, size=2, 
# alpha=.8, coord_fix=F, axes = c("1", "3")) +
#   geom_hline(yintercept=0,linetype=2) + 
#   geom_vline(xintercept=0,linetype=2) +
#   ggtitle("Principal Component Analysis") +
#   scale_shape_manual('Groups', values = 0:5) +
#   scale_color_manual('Groups', values = 
#                        c('#1b9e77','#d95f02','#7570b3',
#                          '#e7298a','#66a61e','#e6ab02') )
```

```{r ade4_plot, eval=FALSE, fig.width=10, cache=T, dpi=300, include=FALSE}
col <- funky(15)

s.class(pca.obj$li, pop(obj), xax=1, yax=2,
        col=transp(col,.6))
title("PCA \naxes 1-2")
add.scatter.eig(pca.obj$eig[1:20], nf=3,xax=1,yax=2)
```

### Correspondence Analysis
```{r ca, dpi=96, cache=T, fig.width=5, fig.height=3}
ca1 <- dudi.coa(tab(obj, freq = TRUE, NA.method = "mean"), scannf=FALSE,nf=3) 

fviz_eig(ca1, main = "Scree plot of CA")
```

```{r ca_plots, fig.width=10, dpi=300, cache=T}
# devtools::install_github('fawda123/ggord')

ggord(ca1, pop(obj), arrow = NULL, txt = NULL, 
      grp_title="Populations", ellipse=T, poly=FALSE, 
      size=2, alpha=.8, coord_fix=F, axes = c("1", "2")) +
  geom_hline(yintercept=0,linetype=2) + 
  geom_vline(xintercept=0,linetype=2) +
  ggtitle("Correspondence Analysis")  +
  scale_shape_manual('Groups', values = 0:5) +
  scale_color_manual('Groups', values = 
                       c('#1b9e77','#d95f02','#7570b3',
                         '#e7298a','#66a61e','#e6ab02') )

# ggord(ca1, pop(obj), arrow = NULL, txt = NULL, 
# grp_title="Populations", ellipse=T, poly=FALSE, 
# size=2, alpha=.8, coord_fix=F, axes = c("1", "3")) +
#   geom_hline(yintercept=0,linetype=2) + 
#   geom_vline(xintercept=0,linetype=2) +
#   ggtitle("Correspondence Analysis")
#   #scale_colour_brewer(palette="Set3")

# loadingplot(ca1$c1^2, threshold = 8)
```

### AMOVA
```{r amova, cache=T}
# setPop(obj) <- ~Country

poppr.amova(obj, ~Country, within = F)
```

### Hierarchical AMOVA
```{r amova_within, cache=T}
# setPop(obj) <- ~Country/Pop

poppr.amova(obj, ~Country/Pop, within = F)
```

### Hierarchical AMOVA - within variation included (as calculated using Arlequin)
```{r amova_arlequin, cache=T}
### Hierarchical AMOVA - within variation included (as calculated using Arlequin)
poppr.amova(obj, ~Country/Pop, within = T)
```

### IBD
```{r ibd, eval=T, cache=T, dpi=300, include=T}
# DGEO IS WRONG SEE WARNING
#change hierarchy to country level
setPop(obj) <- ~Country

obj_pop <- genind2genpop(obj)
Dgen <- dist.genpop(obj_pop,method=2) #maybe only with genepop object
# Dgen <- genet.dist(obj, method = "Ds")
# theoretically any genetic distance can be used
# Dgeo <- dist(obj_pop$other$xy)
geo <- data.frame(popNames(obj))
x <- c(47.81, 46.09, 40.09)
y <- c(12.87, 14.29, 22.44)
geo$x <- x
geo$y <- y
Dgeo <- dist(geo)

ibd <- mantel.randtest(Dgen,Dgeo) 
ibd

plot(ibd)

library(MASS) 
dens <- kde2d(Dgeo,Dgen, n=300) 
myPal <- colorRampPalette(c("white","blue","gold", "orange", "red")) 
plot(Dgeo, Dgen, pch=20,cex=.5) 
image(dens, col=transp(myPal(300),.7), add=TRUE) 
abline(lm(Dgen~Dgeo)) 
title("Isolation by distance plot")
```

### Structure

```{r}
#change hierarchy
setPop(obj) <- ~Country/Pop
```

```{r structure_runs, eval=FALSE, cache=T, include=T}

## Convert input file
        loci <- genind2loci(obj)
        
        ## obj_g <- genind2gtypes(obj)
        obj_g <- loci2gtypes(loci)

struct <- structureRun(obj_g, k = 2:6, num.k.rep = 5,
                            burnin = 1000, numreps = 5000, noadmix = F,
                            freqscorr = T, 
                            ## pop.prior = , 
                            ## locpriorinit = , maxlocprior = , ## locprior
                            ## gensback = , migrprior = , ## usepopinfo
                            ## pfrompopflagonly = , popflag = , ## usepopinfo
                            ## pops = c(""),
                            delete.files = F)

## ## Evanno deltaK
## evanno(gano.struct)
## 
## ## clumpp
## gano.clumpp <- clumpp(gano.struct, k=5, 
##                       delete.files = F)
## 
## ## show membership using strataG
## sp <- structurePlot(gano.clumpp, horiz = FALSE)



```

#### Tests for optimal K
```{r evanno, cache=T}
## read structure runs from pophelper
sfiles <- list.files(path = "./gtypes.created.on.2019.04.27.21.33.22.structureRun/",
                     pattern = "out_f", full.names = T, recursive = T)

        ## include individual names from STRUCTURE file as row names
slist <- readQ(files=sfiles, indlabfromfile=T)

## Evanno pophelper
sr1 <- summariseQ(tabulateQ(slist))
p <- evannoMethodStructure(data=sr1,exportplot=F,returnplot=T,
                           returndata=F,basesize=12,linesize=0.7)
```

```{r evanno2, cache=T, dpi=300, fig.width=10} 
grid.arrange(p)
```


```{r barplots-structure, dpi=300, cache=T, fig.width=10}
## clumpp through pophelper
## clumppExport(qlist=slist[16:20], useexe=T)

## show membership using pophelper
## read aligned file
## aligned <- readQ("./pop_K5/pop_K5-combined-aligned.txt")

## plot
## copy & paste the population column from genalex input file to a csv
# pop_labs <- read.delim("Castanea_SSR_HRM_pops.csv", 
#                        header=F,stringsAsFactors=F)

pop_labs <- data.frame(loci[,1], stringsAsFactors = F)
names(pop_labs) <- "Pop" 
pop_labs$Pop <- as.character(pop_labs$Pop)

## FOR MORE COLOR COMBINATIONS CHECK:
## http://colorbrewer2.org/##type=diverging&scheme=BrBG&n=4
clist <- list(
        "shiny"=c("#1D72F5","#DF0101","#77CE61", "#FF9326","#A945FF","#0089B2","#FDF060","#FFA6B2","#BFF217","#60D5FD","#CC1577","#F2B950","#7FB21D","#EC496F","#326397","#B26314","#027368","#A4A4A4","#610B5E"),
        "strong"=c("#11A4C8","#63C2C5","#1D4F9F","#0C516D","#2A2771","#396D35","#80C342","#725DA8","#B62025","#ED2224","#ED1943","#ED3995","#7E277C","#F7EC16","#F8941E","#8C2A1C","#808080"),
        "oceanfive"=c("#00A0B0", "#6A4A3C", "#CC333F", "#EB6841", "#EDC951"),
        "keeled"=c("#48B098", "#91CB62", "#FFEE3B", "#FB9013", "#FF3C28"),
        "vintage"=c("#400F13", "#027368", "#A3BF3F", "#F2B950", "#D93A2B"),
        "muted"=c("#46BDDD","#82DDCE","#F5F06A","#F5CC6A","#F57E6A"),
        "teal"=c("#CFF09E","#A8DBA8","#79BD9A","#3B8686","#0B486B"),
        "merry"=c("#5BC0EB","#FDE74C","#9BC53D","#E55934","#FA7921"),
        "funky"=c("#A6CEE3", "#3F8EAA", "#79C360", "#E52829", "#FDB762","#ED8F47","#9471B4"),
        "retro"=c("#01948E","#A9C4E2","#E23560","#01A7B3","#FDA963","#323665","#EC687D"),
        "cb_paired"=c("#A6CEE3","#1F78B4","#B2DF8A","#33A02C","#FB9A99","#E31A1C","#FDBF6F","#FF7F00","#CAB2D6","#6A3D9A","#FFFF99","#B15928"),
        "cb_set3"=c("#8DD3C7","#FFFFB3","#BEBADA","#FB8072","#80B1D3","#FDB462","#B3DE69","#FCCDE5","#D9D9D9","#BC80BD","#CCEBC5","#FFED6F"),
        "morris"=c("#4D94CC","#34648A","#8B658A","#9ACD32","#CC95CC","#9ACD32","#8B3A39","#CD6601","#CC5C5B","#8A4500"),
        "wong"=c("#000000","#E69F00","#56B4E9","#009E73","#F0E442","#006699","#D55E00","#CC79A7"),
        "krzywinski"=c("#006E82","#8214A0","#005AC8","#00A0FA","#FA78FA","#14D2DC","#AA0A3C","#FA7850","#0AB45A","#F0F032","#A0FA82","#FAE6BE"))

p2 <- plotQ(slist[1],returnplot=T,exportplot=F,quiet=T,basesize=11,
            # showindlab=T, useindlab=T, 
            ## indlabwithgrplab=T,
            showsp = T, splab = "K=2", splabsize = 11,
            showyaxis=T, 
            # showticks=T, ticksize=0.3, ticklength=0.2 ## y axis
            ,panelspacer=0.4,
            grplab = pop_labs,
            grplabsize=4, linesize=0.8, pointsize=4,
            ## sortind="all",
            divgrp = "Pop", divsize=0.5,
            clustercol=clist$wong,
            panelratio=c(11,1))

## grid.arrange(p2$plot[[1]])

p3 <- plotQ(slist[6],returnplot=T,exportplot=F,quiet=T,basesize=11,
            # showindlab=T, useindlab=T, 
            ## indlabwithgrplab=T,
            showsp = T, splab = "K=3", splabsize = 11,
            showyaxis=T, 
            # showticks=T, ticksize=0.3, ticklength=0.2 ## y axis
            ,panelspacer=0.4,
            grplab = pop_labs,
            grplabsize=4, linesize=0.8, pointsize=4,
            ## sortind="all",
            divgrp = "Pop", divsize=0.5,
            clustercol=clist$wong,
            panelratio=c(11,1))

## grid.arrange(p3$plot[[1]])
```

```{r barplots-structure2, cache=T}
## A new chunk was created for plotting to avoid producing an empty plot
## https://support.rstudio.com/hc/en-us/community/posts/239529128-Notebooks-grid-newpage
grid.arrange(p2$plot[[1]])
grid.arrange(p3$plot[[1]])
```

### DAPC

### Ne estimation (strataG)

# Comparison with microsatellite data

### Mantel test microsattelite vs SNPs

# Observations

- Some SNPs are only typed for the greek populations, and were not included in this
analysis. They should be investigated further.

# Reproducibility
```{r reproducibility}
devtools::session_info()
```

# Bibliograpy